#### 15. SICP，第3章，模块化、对象和状态
+ 大纲
    + 引
        + 基本过程+组合+抽象，可能仍不足以克服大型系统的复杂性，有效的综合程序还需要一些组织原则，即将系统"自然的"划分为一些具有内聚力的部分，使这些部分可以分别的开发和维护
        + 组织程序的方式会受到我们对于被模拟系统的认知的支配
        + 两种特点鲜明的组织策略
            1. 将大型系统看成一大批对象，他们的行为可能随时间变化(行为受历史影响，即有状态)
                + 目标是，在需要扩充系统时，不需要做全面的修改，而只需要加入与这些对象获动作相对应的新符号对象。扩充和排错都只需要做一些局部性的工作
                + 在lisp中，需要抛弃代换模型(substitution model of computation)，改为机械、更不容易把握的环境模型(environment model of computation)
                + 在处理对象、变化和标志时，各种困难的根源是我们需要在这一模型中和时间搏斗。并发程序中，事情又会困难很多
            2. 类似电子工程师观察信号处理系统一样，将注意力集中在流过系统的信息流上
                + 能够解耦模拟真实时间时的各种计算顺序依赖
    + 赋值和局部状态
        + 局部状态变量
            + 所谓"有状态"，就是说，它的行为受历史的影响。在很多系统中，我们只维护当前值，而不是记住账户的全部历史
            + 如果一个系统中的状态变量可以分组，形成一些内部紧密结合的子系统，每个系统与其他系统之间仅存在松散联系，此时将这个系统看做由一些独立对象组成的观点就特别有用
        + 引进赋值带来的利益
            + 以复杂计算过程中的一部分的观点来看，其他部分都是在随时间不断变化的，而用局部状态模拟状态、用赋值模拟变化，可以让各个部分隐藏自己的变化，从而分解系统
            + 引进赋值和将状态隐藏在局部状态中的技术，避免了对所有状态进行显示的传递和返回，使得我们能更模块化的构造系统
                + 如果以纯FP的风格来组织这种复杂程序，恐怕所有的过程都必须传入和返回一个叫global的hashtable
        + 引进赋值的代价
            + 在代换模型中，一个ID，引用的是一个值；而在环境模型中，一个ID，引用的是一个存储位置
            + 关于别名(aliasing)：代换模型中，两个ID值相等和它们引用的是同一个对象，是一个概念，即不区分是否共享；在环境模型中，曾经相等的值的两个ID可能在之后不再相等，因为引用不同
                + 换句话说，在无赋值环境中，equal?为true，即可以认为是同一个对象；而在赋值环境中，eq?为true，才是同一对象
            + 引入赋值破坏了程序的引用透明性(referential transparency)
            + 不用任何赋值的程序语言称为函数式程序语言(functional programming)，而广泛采用赋值的程序设计被成为命令式程序设计(imperative programming)
            + 赋值顺序不同，程序的结果不同，因此带有赋值的语言强迫人们去思考赋值的相对顺序，确保修改作用在变量的正确版本上。这个问题在并发访问共享数据上尤为困难
    + 求值的环境模型
        + 求值规则
            + 引入副作用(赋值)后，一个S表达式中的子表达式的求值顺序变得重要，但我们不应该写出依赖于这种顺序的代码
            + 规则
                1. 求值一个lambda表达式，将会创建一个pair，它包括lambda的过程体和求值该lambda表达式的环境
                    + lua中，出于优化考虑，function对象不会包含整个创建时环境，而只是捕获一系列的upvalue，具体的upvalue集合，是`upvalues of this function + (upvalues of inner function - locals of this function)`
                2. 调用一个过程，将创建一个新的环境，其中形参名字会规约到实参值上；这个新环境的外层环境是过程pair指向的环境，即创建该lambda时的环境
                    + 该方案叫做lexical scoping；相对的，如果外层环境指向栈的外层，那么就是dynamic scoping
                    + define这个spectial form，将会在当前过程的环境中添加一个新名字
    + 用变动数据做模拟
        + 变动的表结构
            + 如果能够通过FP或其他的方案实现组合数据的cons/car/cdr，那么，藉由set!，也能够实现set-car!/set-cdr!
            + 可以通过get-new-pair+set-car!+set-cdr!来实现cons
            + 注意append!，它将两个列表连接起来，避免了像append那样，创建length(list1)个新pair(特殊编译器的优化可能会导致append!更慢，因为要求mpair，但至少在racket目前的实现中，append!的确更快)
            + 创建循环链表，只能用mutable pair(或者stream)
            + 对一颗树调用count-pairs，如果没有赋值(immutable pair)，那么，一个pair绝不可能重复出现，因此简单的递归求和即可；但如果允许赋值，那么需要将mpair搜集到一个set中，最后求set的size
        + 队列的表示
        + 表格的表示
        + 数字电路的模拟器
        + 约束的传播
    + 并发：时间是一个本质问题
        + 并发系统中时间的性质
        + 控制并发的机制
    + 流
        + 流作为延时的表
        + 无穷流
        + 流计算模式的使用
        + 流和延时求值
        + 函数式程序的模块化和对象的模块化
+ 启发
    + 对于纯函数来说，相同的输入必然产生相同的输出，因此可以做cache、lazy evaluation、parallelism等
    + 蒙特卡罗法(mente carlo)：基于概率求值
        + 例，6/(pi^2)是随机选取两个整数之间没有公因子的概率
        + 例，用谓词P描述在一个函数内部(比如x^2+y^2<=1表示一个圆)，那么，用函数的包围矩形中随机的点通过P的概率，乘以矩形的面积，就可以得到函数在这个矩形区间中的定积分(integral)。这种方法叫蒙特卡罗积分
    + 引用透明性(referential transparency)：一个表达式用它的值替换过后，不会影响程序的结果。潜台词是，表达式没有副作用，即相同的输入总计算出相同的值
    + 别名(aliasing)：如果对一个名字的修改，可能由于副作用，影响到另外一个名字，那么，这两个名字实际上是同一个对象的别名。某些人建议说，程序设计语言中不应该允许副作用或别名。
    + racket中的mutable pair叫mpair，相应的有mcons/mcar/mcdr

#### 15. 杂项
