#### 6. SICP，第4章，元语言抽象
+ 大纲
    + 引
        + 建立新语言是在工程设计中控制复杂度的一种威力强大的工作策略，因为新语言能使我们以一种完全不同的方式，利用不同的原语、组合以及抽象去描述和思考问题，这些要素都是为了处理专门问题而打造的——显然，通用语言不太可能内置这些解决方案
        + 本书中已经多次演示了定制语言：图形绘制语言、数字逻辑模拟器、约束传播系统(constraint propagation)
    + 元循环求值器(Meta circular evaluator)
        + 引
            + 用与被求值的语言同样的语言编写求值器，叫做元循环
            + 求值器的基本元素
                + 处理嵌套表达式。即组合
                + 定义复合过程。即抽象
                + 使用变量。即基本元素
                + 特殊形式(special forms)。特殊的求值规则，即语法。在lisp中，被叫做宏
        + 求值器的内核
            + eval需要针对不同的form进行dispatch
                + 对于boolean、string、number等self evaluation的值，返回本身
                + 对于变量(symbol)，从环境中找出对应的值。这里包括基本过程
                + quote，返回正文。
                    + 当然，还有quasiquote、unquote、unquote-slicing
                + set!，修改变量所在的环境
                    + define。正确的define实现，应该是以'undefined作为初始值来let要define的变量，然后以set!替换原来的define调用
                + if，先求职predicate，再求值then或者else
                + lambda，保存求值lambda时的环境；调用复合过程本身的时候，以形参约束(bound)实参、扩展环境，再用新环境求值过程体
                + begin，按顺序求值
                + library forms(derived forms)。在实际操作中，它们可以通过macro+fundamental form实现。common lisp的宏会有些问题，而scheme的hygienic macros则比较健全
                    + cond, and可以用nested if实现
                    + or可以用let + if实现
                    + let/let*可以用lambda实现
                    + named let可以用define+lambda+call实现
                    + letrec可以用lambda+define实现
                    + begin可以用嵌套的lambda实现
                    + do可以用named let+if实现
            + 可以将复合过程(lambda)实现为结构或者host过程，有细微区别:
                + host过程：对caller来说无法区分host过程和lambda，因此无法实现特殊求值方式；但是实现上会简单点点
                + 结构：实现会稍微复杂一点。但在进行过程调用的时候，由于可以区分host过程和target过程，因此就可以利用caller的环境，从而实现call-by-name/call-by-need/call-by-reference等精确控制的argument passing mechanism，要实现cps interpreter等可能也会稍微饶一点
            + 在求值变量的时候，沿着环境中的frame链逐个查找的方式叫做deep binding(深约束)；一种优化策略是，在编译期，将每个变量的symbol翻译成词法地址(lexical address)，然后运行时可以直接以frame index+variable index进行lexical addressing
        + 将语法分析与执行分离
            + 这是一种partial evaluation的应用，将原来运行时的pattern analysis转到了编译期，减少运行时的工作，我将之看做一种编译
            + 这种partial evaluation的手法在各种场合都可以使用，比如pattern matching, 以及包括kmp在内的各种预处理算法
                + 关键思路：算法会多次运行，而多个运行实例间，有一部分公共参数，或者叫做静态参数、pattern；通过将这部分静态参数提取出来，进行一次原算法+静态参数的预处理，生成包含静态参数信息的新算法，最后作用于各组动态参数
                + 形式化的描述一下。有多次计算：A1(S + D1), A1(S + D2), ... A1(S + Dn)，通过将A1(S)编译成A2（这个过程即partial evaluation，而生成的A2是partial application；当然，相比之下，currying的输出是一种极简的parital application），最后将原来的计算替换成A2(D1), A2(D2), ...A2(Dn)，由于A1+S只计算了一次，从而提高了性能
    + Scheme的变形——惰性求值(Lazy evaluation)
        + 正则序和应用序(Normal order & Applicative order)
            + normal order和applicative order是用来描述一门语言的属性，前者指实参的求值会延迟到实际需要的时候(IO或者和其他系统的接合处)，后者指实参的求值会发生在调用过程前
            + 如果某个参数的求值发生在进入过程体之前，则成这个参数相对于这个过程是严格的(strict)；反之，如果还没求值就进入过程，则成为nonstrict
            + normal order一般是语义层面的概念，而lazy evaluation往往是指一种实现层面的手法
            + normal order是语言语义层面的概念，而nonstrict是某个参数相对于过程的属性
                + 一般的scheme都是applicative order的，但stream-cons的cdr参数、甚至包括car参数是nonstrict的
        +  一个采用惰性求值的解释器
            + 比起stream-cons这样通过special form来实现lazy evaluation，让整门语言变成normal order的好处是，具有nonstrict参数的过程可以被当做first-class值用于过程参数和返回
            + 在scheme社群中，以thunk称呼lazy得到的延迟对象，通过force来迫使thunk对象求值；如果thunk本身带有缓存，那么往往用于实现call-by-need，如果没有缓存，则被用于实现call-by-name
    + Scheme的变形——非确定性计算(nondeterministic computing)
        + amb和搜索
            + amb是John McCarthy在1961年第一次提出的
            + 本节的amb实现是基于历史的回溯(chronological backtracking)，或称为深度优先搜索
            + 自动搜索的历史
                + 1967年，Rebert Floyd第一次提出可能通过搜索和自动回溯，把非确定性算法很优雅的做紧程序设计语言里
                + 1969年，Carl Hewitt发明了Planner程序设计语言，它显示支持自动按历史回溯`(automatic chronological backtracking)`，采用depth first search
                + 1971年，Sussman、Winograd和Charniak实现了Planner的一个子集，叫做MicroPlanner，用于支持问题求解和机器人规划工作
                + 类似的想法也出现在逻辑和定理证明领域，导致Prolog语言在爱丁堡和马赛诞生
                + 1972年，由于自动搜索遇到极大障碍，McDermott和Sussman开发了一种名为Conniver的语言，包含程序员控制下的搜索策略安排机制，但这种方式被证实难以使用
                + 1975年，Sussman和Stallman在研究电子线路的符号分析过程中创建了一种更容易控制的方法，他们开发出一种基于相互关联的事实之间的依赖关系的非历史的回溯模式，被称为依赖导向的回溯`(dependency-directed backtracking)`。虽然方法比较复杂，但性能可接受了，因为工作中很少做多余的搜索
                + 1979、1980年，Doyle和McAllester推广并进一步澄清了Sussman和Stallman的方法，开发了一种新的构造搜索形式，被称为正确性保持`(truth maintenance)`。新型问题求解系统都用了某种形式的正确性保持技术
                + 1987年，Zabin、McAllester和Chapman描述了Scheme的一种基于amb的非确定性扩充，采用的是依赖导向的回溯
        + 非确定性程序的实例
            + 解逻辑题
            + 依赖于搜索的数值题
            + 一个例子，自然语言语法分析
        + 实现amb求值器
            + 原理：
                + cps解释器
                + 保存continuation后，可以在任何时候通过调用continuation来返回过去的某个程序状态(通过监听set!，在backtracking的时候进行undo)；因此，管理一系列的continuation后，就相当于拥有了一部时间机器，这就是amb的本质
                + 该amb解释器通过将每个amb form调用点上的continuation及一系列的备选值保存起来，链接到fail closure chain中，在计算失败的时候取出并执行顶上的fail closure就相当于取出最近的一个continuation和备选值进行回溯
                + fail closure chain其实就是continuation + value的chain，它们就是continuation的管理者，也就是时间机器的核心
            + 用call/cc辅以显示的continuation+value链，也能实现amb
    + 逻辑程序设计
        + 关键
            + pattern matching，模式匹配。输入一个模式和数据，将模式中的变量绑定到对应的数据
                + 在scheme中，linear pattern matcher，无论是运行时还是编译期的都很好写，注意运用partial evaluation去掉运行时的模式分析
            + unification，合一。pattern matching的推广，匹配的两边都是模式，因此，一次unification结束，可能两边都还有变量没约束到具体的数据，但只要没发生匹配失败，那合一仍然可以结束
+ 启发
    + 一个简单的求值器有可能去模拟远比求值器本身复杂的各种程序，尽管这种结果可能会稍微违反直觉
    + 图灵提出的停机问题，是清晰给出的第一个不可计算问题：一个良好刻画的工作，却不能由一个计算过程完成
        + 不可能写出过程halts?，用于判断一个程序是能停止:

            (define (test f)
                (if (halts? f)
                    (test f)
                    'halted)
            )
            (test test)
    + 不借助define实现递归：Y combinator
        + 在C++这种无GC环境中，它还是一种存储上的解决方案（打破了lambda递归时的存储限制）
        

#### 6. SICP，第5章，寄存器机器里的计算
+ 大纲
    + 寄存器机器的设计
        + 相比标准x86过程的calling convention，手工调优的汇编的访存能够更精确，比如fibonacci的尾递归实现，能够只使用寄存器！(当然，本质上只是一个for循环的迭代)
        + 本节中的指令集
            + 数据传输
                + (assign (reg target) (reg source))
                + (assign (reg target) (constant c))
                + (assign (reg target) (label l))
            + 算数运算
                + (assign (reg target) (op +) inputs ...)
            + 跳转
                + (test (op =) inputs ....): 测试，影响状态寄存器
                + (branch (label l)) : 条件跳转
                + (goto (label l)), (goto (reg target)): 非条件跳转
            + 栈操作
                + save
                + restore
            + IO
                + (assign (reg target) (read)): 输入
                + (perform (op print) inputs ...): 输出
    + 一个寄存器机器的模拟器
        + 机器模型
        + 汇编程序
            + 这里的汇编，也是一个partial evaluation的过程，将上面的指令集文本(语法树datum)转化成可调用的过程，其中会将寄存器的位置、label的地址等都取出来
        + 监视机器执行
            + 一个比较有意义的统计是，统计栈的入栈和最大栈深，以衡量访存频率 ；如果是有内存寻址模式的指令集，也应该衡量访存次数
    + 存储分配和垃圾回收(Storage allocation & Garbage collection)
        + 将存储看做向量
            + 这里的list，其实是采用了cons的get-new-pair+set-car!+set-cdr!版本实现！
        + 维持一种无穷存储的假象
            + 这里用汇编(前文描述的指令集)实现了一个compacting gc
    + 显示控制的求值器
        + 显示控制求值器的内核
            + 这里用汇编实现了一个scheme解释器，入口是eval-dispatch
            + 必须区分基本过程(机器直接支持的运算如+-*/)和lambda建立的复合过程，后者需要递归
        + 序列的求值和尾递归
            + 注意这里用汇编实现的尾递归优化，避免了栈积累
    + 编译
        + 引
            + 编译大大提高了程序的效率，而解释则为开发和排错提供了更好的环境
            + 现实中的lisp系统往往是编译和解释的结合，对于库等稳定过程，直接将过程编译成native code(当然需要和运行时系统链接在一起)，而对于用户自定义代码，则可能是解释执行，但解释和编译的过程可以交换调用
            + 编译比解释快很多
                + 对源码的解释和错误诊断移到了编译期，没有运行时开销
                + 可以针对特殊情况进行特化，不需要考虑不同的可能。比如一个self-evaluating的值，可以直接返回本身，而无需走eval流程；也可以判断一个过程是内部过程，从而直接调用
                + 对于变量求值，由于可以在编译期进行分析，从而进行lexical adderssing而不是deep binding，加速变量查找
        + 编译器的结构
            + 类似解释器的eval，遍历语法树，不过不再是env+exp返回value，而是exp+symbol-table+next返回instruction-list。类似龙书里的语法制导的翻译(syntax directed translation)
            + 不知这是否算是一种abstraction interpreting
            + 要减少不必要的存储器访问。比如尽可能少的save/restore
        + 词法地址
            + 通过编译期的symbol-table，将所有的变量引用转换成词法地址(即frame index+variable index)
            + 由于所有的local definition都可以翻译成let，所以所有的bound variable和free variable都有词法地址
            + 对于全局变量，它没有词法地址，但是可以在编译期判断一个变量的全局/词法属性，因此，如果一个变量是全局变量，那么，可以在运行时直接在全局frame中查表，而非沿着frame list逐帧查找的deep binding
                + 全局变量无词法地址的这种限制，是由于top level definition存在导致的
                + 可以进行一个小小的优化，将全局变量访问也优化成lexical addressing。即引入一个数组，里面存放的是全局变量的地址，其中每个地址和global hash table中的地址相同，从而单个文件中的全局变量能够直接使用该数组的索引来访问
        + 编译代码与求值器的互连
            + 同一系统中同时提供编译和解释两种方案，供用户混合使用，用户可以将稳定和易变的部分分别编译和解释，从而运行效率和开发效率两不误。这就要求系统提供编译模块和解释模块的互相调用机制
+ 启发
    + 关于编译(compiling)
        + 被硬件直接解释执行的语言称为native language或者machine language
        + 通用计算机的电路实现的是其指令集的解释器，是为解释器专门定制的
        + 如果不考虑通用计算机高度优化的事实的话，为每个程序生成专门的硬件电路并生产机器，专门用于执行该程序，才是最快的
        + 考虑到为每个程序都生成电路，成本太高，一种折中是，为每种语言的解释器(只不过是一个特殊的程序)生成电路并生产机器
        + 作为用于实现解释器的硬件代表:
            + 8086，实现的是寄存器语言的解释器(即x86)，包括数据传输、算数/逻辑运算、条件/非条件跳转等指令
                + native语言是x86，硬件是x86的解释器
                + x86由硬件直接解释执行
                + 对于高级语言A，如果A的解释器是用x86编写，而A语言的源码交给该解释器解释执行，那么机制叫做解释(如lua/bash)
                + 对于高级语言B，如果B的编译器是用x86编写，而B语言的源码交给该编译器翻译成x86执行，这种高级语言被翻译成native语言后再执行方式，叫做编译(如C/C++)
            + lisp machine，该硬件实现的是lisp解释器，硬件操作包括car、cdr等
                + native语言是lisp，硬件是lisp解释器
                + lisp由硬件直接解释执行
                + 对于高级语言A，如果A的解释器是用lisp编写，而A语言的源码交给该解释器解释执行，那么这是解释(比如lisp machine上的C解释器，当然，这种做法可能会比较少，静态编译型语言多半会直接编译)
                + 对于高级语言B，如果B的编译器是用lisp编写，而B语言的源码会被该编译器翻译成lisp后再执行，那么该过程叫做编译(如C->lisp的编译器)
    + 对于高级语言C和现有体系结构S1，如果将C移植到体系结构S2中呢？
        1. 直接用S2编写C的解释器，然后将该解释器放到S2机器上，于是S2机器上的C源码能被解释执行
        2. 用C编写C->S2的编译器，然后将这个用C语言编写的编译器在S1机器上编译成S1程序
            + 利用S1上的编译器，编译各种C语言程序到S2，然后将输出的S2程序拿到新机器上运行。这叫交叉编译(cross compiling)，Android/iOS开发环境中编译器就是运行在x86上的交叉编译器
            + 利用S1上的编译器，编译该编译器的C源码本身，得到一个工作在S2上的C->S2的编译器。这叫自举(bootstraping)。有了这个能在S2上运行的新编译器，于是可以在S2上写C代码并独立编译了
            + 利用S1上的编译器，编译C解释器的C源码，得到一个S2上的C语言解释器，从而能在S2上解释执行C语言。这个解释器的运行速度和1.中的手工解释器不同，区别是手工汇编和编译器输出的优化水平差距

#### 6. 杂项
+ 对continuation和cps的理解
