#### 9. 杂项
+ 关于GC
    + .Net的Generational GC第0代默认选择256K，因为这是L2的大小
    + JVM的分代GC概念
        + 三代
            + Young generation
                + Eden, 空间x8
                + Survivor from, 空间x1
                + Survivor to, 空间x1
            + Old generation
            + Permanent generation
        + 分配的时候，在Eden和Survivor from上，一旦满额，就应用Copying GC的机制拷贝到Survivor to中，如果Survivor to空间不足，则拷贝到Old generation中。典型的，Young generation的一次GC希望回收90%
        + 如果只对Young generation回收，则称为minor GC；否则称为major GC或full GC
        + Old/Permanent generation对Young generation的引用通过card table来标记
+ 几种GC的对比
    + mark and sweep
        + 复杂度：标记阶段是O(a)，这里的a是活跃对象；清扫阶段是O(n)，需要遍历每个对象
        + 指针不被搬移，地址稳定，可以利用memory pool，比如tcmalloc
    + copying gc
        + 复杂度：O(a)，只处理存活的对象。因此对于第0代这种回收率极高的场合，非常适合
        + 指针搬移，GC完毕后需要更新所有对象、以及栈上寄存器/临时变量中的的指针；或者总是用Handle来访问
        + 分配迅速，只是freeOff的加法
    + mark and compaction
        + 一般4趟：
            1. 根据reachable graph，遍历标记
            2. 遍历整个堆，为每个存活对象计算新地址，保存在对象头的forward字段中
            3. 遍历整个堆，对于每个存活对象，遍历其中的每个引用字段，将字段值替换为旧指针对应的forward值
            4. compaction
        + 复杂度O(n)，因为需要多次遍历所有的块
        + 指针搬移
        + 分配迅速，加法
+ 对于variant/any/object的概念，常见的实现方案包括，tagged union和tagged pointer，以及object指针
+ C++中的转型
    + 对于有符号、无符号，姑且允许直接用C-style转换
    + 对于class/struct指针，一定要用`static_cast`等C++-style转型，因为后者包含了更多的类型信息，可以在编译期检测出逻辑错误
        + 比如，对于A和B这两个类型，你期望他们有继承关系，所以用`static_cast`来处理指针转换，但由于人为失误，他们没有继承关系，这时，C++编译器会检测出该`static_cast`使用非法；如果你确实要在两个没有继承关系的指针间转型，就应该确实的使用`reinterpret_cast`。此为利用类型信息发现逻辑错误的典型
+ 在Scheme解释器中统一数据和代码的方式(跟quote有关)
    1. 代码和数据是同一格式，比如用Scheme、Python来写解释器，代码和数据都用list表示。浓浓的FP味儿
    2. 代码是经过词法寻址后的优化形式，而数据是纯粹的列表，(eval (quote ...))的时候，需要将列表编译优化过的代码形式。实际的高性能解释器方案
+ 关于实现Scheme解释器的几个层次
    1. 递归解释器，宿主语言(解释器的实现语言)不支持尾调用优化(如Python/C#/Javascript): Scheme程序轻易栈溢出(尤其考虑到Scheme中用递归表达循环的风格)
    2. 递归解释器，宿主语言支持尾调用优化(如C++/Lua)，或者将eval手工改为尾递归优化形式(修改eval参数后goto到函数开始): Scheme程序中的尾递归函数不再栈溢出，但大量的非尾递归仍然溢出(如cons)
    3. 递归CPS解释器，或者用普通的递归解释器解释经过全文CPS变换后的Scheme程序：不再有栈溢出
        + 这里有一个考虑，用户自定义函数肯定是CPS风格了，那内置函数呢？DS风格？慢了。如果内置函数和自定义函数都需要作为高阶函数传给map等函数作为参数呢?
    4. 字节码解释器，使用ADT的stack来实现脚本栈而不再是复用native栈：不再溢出
        + 在输出的字节码中插入tail指令，进行tail call optimization，性能提高显著
+ Python的tuple赋值左端，可以当做一个简单的模式匹配器使用
+ 关于VCPS
    + 用于做迭代器很方便
    + 对于递归CPS解释器来说，要求宿主语言支持尾调用优化，如果不支持的话，如C#，就需要写成VCPS风格。但其实无需全文都写成VCPS风格，只需要在几个关键点，如求值application时将最后一步apply给换成(cons args k)即可
        + 经实测，这将VCPS的中间pair结构数量下降到1/4
+ 全文CPS变换程序中用到的CPS本身的一个技巧：
    + k(result)的返回值仍然可以进一步处理！即还可以包裹一层ctx！如(ctx (k result))
    + 合理利用k的返回值，在特殊场合下可能大幅简化程序！
+ 4类lambda环境模型
    1. 堆环境：如Scheme、Javascript的原始模型
        + 调用一个函数的时候创建一个新环境块儿，所有局部变量都放在里面；在该作用域内创建函数时，会保存整个局部环境作为free varaible寻址用
        + 没有块级作用域
    2. 堆变量
        + 每个局部变量都是Ref<object>的引用，创建函数时，函数会引用它以及它内嵌的子函数需要的free varaible的Ref<object>引用。Ref<object>通过引入了一个间接层，让局部访问以及free variable访问都能共享的作用到其他作用域，因为只保存了一份数据，所以所有引用总是同步更新
        + 支持块级作用域
        + 相当于lua模型的一个简化
    3. 栈环境+堆环境：如C#的lambda
        + 分析局部变量中会作为free varaible被引用的集合，在进入函数体过后就创建heapEnv对象，对于非free varaible局部变量，总是通过stack[i]来访问，而对于会被内层引用的变量，总是通过heapEnv[i]来访问。创建函数的时候保存heapEnv对象。
        + 该方案比堆环境模型更优化，但同样不支持块级作用域
    4. 栈变量+堆变量：如Lua
        + 局部变量放在栈中；当创建函数时，对于函数及内嵌函数需要引用的free varaible，创建upValue对象，其内包含一个局部变量地址；当退出作用域时，利用close指令，将当前深度的作用域对应的所有的upValue给close掉，即将栈指针指向堆中
        + 支持块级作用域
+ 对于不支持块级作用域闭包的语言，如Scheme、C#
    + Scheme中的循环是递归风格，总是创建新环境，块级作用域的问题不明显
    + 对于C#、Go、Javascript，总是可以通过`(function() {})()`来模拟块级作用域。尤其是在动态语言/类型推导完备的静态语言中特别好用
+ 在一个经过CPS全文变换的程序中，有两类函数
    1. 原始代码中的函数，现在全为CPS风格，即总有一个k参数
    2. 变换引入的k函数。原始码中透明、无法访问
+ 递归的数据结构还是递归算法最自然
    + 比如parser
    + 比如迭代
+ C/C++的实参求值顺序不定！
+ 在一个Copying/Compaction GC系统中，保存裸指针是危险的，除了应该确保指针可达外，还应该总是通过类似Handle的间接层来访问指针
+ 加速解释器一个方法是为常用操作提供专门指令、降低解释开销。如
    + load0, load1, loadnil
    + loadlocal0, loadlocal1, loadfree1, loadfree2
    + tjmp, zerojmp, niljmp, eqjmp, lessjmp
    + inc, dec
+ 字节码解释器中，也可以将callstack隐式的放入evalstack中
+ 关于yield、async/await，可以通过实现first class stackframe来实现
    + 需要提供的支持:
        1. 原语stackframe: 利用函数对象及实参，创建stackframe对象
        2. 原语yield: 将callstack顶上的stackframe弹出
        3. apply时除需要支持native function、script function，还需要支持stackframe对象作为operator
    + 在该机制下，(+ 2 3)等价于((stackframe + 2 3))；对于不包含yield的函数，后者等价于前者，如果包含yield，那么就不同了，可以先(stackframe f 2 3)得到stackframe对象，再多次apply
    + 相对的，coroutine需要first class stack的支持。
+ 关于抽象解释
    + 将值域缩小到特定范围后的解释过程
    + 例子
        + 编译。环境是符号表，值域是代码
        + 静态分析。环境是符号表，值域是类型等规则
        + 类型系统。环境是符号表，值域是类型
        + 正负号的求值系统。环境是符号表，值域是+-0
        + 解释代码求evalstack深度。环境是符号表，值域是深度
        + CPS变换：环境是上下文，值域是变换后的代码
        + 寄存器分配: 环境是寄存器使用上下文，值域是寄存器名
+ 关于dynamic scoping
    + 作用域查找，即确定变量在哪个作用域，叫scoping
    + 作用域查找即变量位置查找，叫addressing
    + 所谓lexical adderssing，是指能够通过源码推断出变量的地址，即编译期寻址。是一种eager binding
    + dynamic scoping，是指在运行时进行变量定位，分两种:
        1. 基于execution context查找。这里的execution context即env chain。比如Javascript的with
        2. 基于calling context查找。即基于调用栈帧查找。比如Common lisp中的dynamic scoping
+ 在支持first class function的语言中编写递归，应该注意避免函数体依赖函数名，特殊用法除外(如memoize)
    + 对于javascript，有named function expression
    + 对于scheme，有named let；其他语言类似
+ Javascript经验
    + 少用for-in
        + 基于prototype的OB/OO用法，for-in会遍历prototype中的类方法，多半不是你想要的结果。必须结合hasOwnProperty
        + 用for-in遍历数组很慢，得到的索引i甚至可能是字符串！
    + 对于值类型Number/Bool，尽量不要扩展prototype，因为2.method可能会被处理成new Number(2).method，而2 === new Number(2)是false的，所以会有坑...
    + 在JS这种语言中，应该逆向遍历
        + a.length如果作为结束条件，那么每次迭代都要进行属性访问，哪怕是inline caching，都会更慢
        + 如果遍历的是IE中的NodeList，那么a.length是COM对象的属性访问，超慢...
    + Douglas Crockford的JS编码建议
        1. 只用===和!==，而不是==和!=
        2. 不用with。它会破坏lexical addressing，在v8中测试，会比普通的属性访问慢几百倍
        3. 小心eval，它有性能问题和安全问题
        4. 总是使用function expression而不是function declaration，因为后者会自动提升，可能成为坑
        5. 永远不要出现new String(), new Number(), new Boolean(), new Object(), new Array()
    + 总是使用'use strict'
+ npm install -g pkgname可以安装包到全局；再通过npm link pkgname加到本地供require

#### 9. Javascript高级程序设计，读书笔记
+ ECMAScript的诞生是因为浏览器厂商的竞争，多个Javascript的行为不一致导致上层开发困难，才标准化
+ ECMA-262定义的ECMAScript与Web没有依赖关系，它只定义了语言的基础，不包括IO。常见的平台包括：
    + Web。DOM+BOM
        + DOM的标准化也是因为IE和Netscape关于DHTML的竞争
            + DOM1: XML和HTML
            + DOM2: 鼠标和UI事件、范围、遍历、CSS、视图
            + DOM3: DOM文档的加载和保存；DOM验证
        + 还有几种对应DSL的DOM标准
            + SVG
            + MathML
            + SMIL
        + BOM本身没有标准，只能针对浏览器适配。HTML5解决了这一问题，包括操作浏览器窗口和cookies等功能
    + Node
    + Adobe flash
+ `<script>`标签最好放到body最后，这样，加载script之前可以先显示其他元素，而不至于空白
+ 外部`<script>`的优点:
    + 可维护。比如版本控制
    + 浏览器可缓存，避免重复下载
    + 不需要内部`<script>`的一些注释hack等(比如<到底应该被当做小于还是tag的一部分)
+ JS编码风格
    + 用''来表示字符串。这样，JS代码片段可以被插入html属性的""中
    + 总是用`;`而非换行来分割语句，为了JS源码可压缩(移除空格和换行)。也算是对运行时JS parser性能有所帮助
+ DOM、BOM中的对象都是宿主对象，其行为不受ECMA-262约束。比如IE中的DOM对象就是COM
+ ECMAScript的Number是IEEE754规定的双精度浮点，但bitwise op是作用在32bit整形上的，JS解释器自动转型
+ JS和Java一样通过>>>和<<<来处理逻辑移位
+ 引用未定义变量会抛错，但if/短路逻辑中的未定变量引用，只要没执行就不抛错
+ 没有goto label，但是有break label、continue label
+ 关于属性枚举
    + obj.hasOwnProperty(), Object.keys(), Object.getOwnPropertyNames()，访问的都是instance proprety
    + for-in, in访问的是instance + prototype的property
+ JS的switch相当于if/elseif，因此case中可以出现任何类型和表达式(甚至是运行时表达式)
    + switch的case匹配用的是===
    + switch(true)，然后每个case都是test，是典型用法，用来代替if/elseif列表
+ 总是可以用arguments来访问实参；如果形参太多，那么多余的形参是undefined
+ 没有返回的函数，实际返回undefined
+ String是基本类型，不是Object的派生，因此不能添加属性
+ typeof和instanceof
    + typeof依据type tag，可以识别基本类型和object；虽然function实际上是一种callable的object，但为了方便使用，会返回'function'
    + instanceof依据prototype chain，而对象隐藏的prototype，是在new时绑定的。因此instanceof多用于OO
+ ECMAScript的全局环境，在Web上可以通过window来访问，在Node中通过global访问
+ 注意字典literal也是在new Object，因此它的prototype就是Object.prototype
+ object的属性名总是string
+ 在API设计中，可以用字典来整合optinal参数
+ a.length = n；可以直接扩展/收缩数组
+ 如果存在多个window/global对象的话，instanceof用来判断Array/String/Date就不靠谱了，所以应该用内置函数Array.isArray, Date.isDate等
+ Array.prototype.sort默认是基于对象的toString比较，因此一般都应该传入特殊的比较器
+ JS中没有块级作用域，var声明都会自动提升，效果等同于C语言中只能在函数开始声明所有变量
+ 写递归时，通过arguments.callee来递归比直接引用函数名或者function expression名字要慢很多
+ this是lexical addressing的，它和arguments一样，是隐含参数。如果调用方不是dot expression的话，函数体中的this就被初始化为window(严格模式中是undefined)
+ 严格模式下不能访问arguments.caller是出于安全考虑，避免访问调用方的源码字符串
+ eval访问的是全局环境(window/global)
+ Object.defineProperty访问属性，可以定义writable，getter/setter等
+ Object.preventExtensions禁止添加属性；Object.seal，进一步，禁止修改property的属性；Object.freeze，再进一步，不允许写属性值
+ 构造函数也只是普通函数，如果不用new而是直接调用，结果是将属性绑定在了window/global对象上
+ 对象内部持有的是new时刻的prototype，因此修改旧的prototype对象，对象行为改变；而修改构造函数的prototype属性，早创建的对象不受影响
+ 闭包实现的OO有属性的受限访问这个好处
+ JS中的常见对象模型
    + OB：设置构造函数的prototype，然后new
    + OO: 将派生类的构造函数的prototype设置为基类的对象，或者从基类构造函数的prototype中Object.create出来；派生类的构造函数要base.call(...)来初始化基类属性；最后new
    + Object.create，访问链，有点像运行时的with
+ JS的声明提升和Scheme中的不一样，前者相当于语句直接出现在了函数开头，而后者是被define被拆成了开头的define以及后面的set!；从正确性上来说，后者更容易理解，没坑
+ JS不支持块级作用域；但似乎全局环境下的块却是有局部作用域的...
+ JS中obj.method返回的不是bound function，需要手工bind
+ module模式很常见，避免了全局名污染
+ 引用没有声明的全局变量会抛错，但是window.name却只是返回undefined
+ 如果允许注册回调，不应该用callback != null来判断，而应该typeof callback == 'function'；即，总是用typeof/instanceof来确认变量是你要的；更进一步说，想要什么，要说明的足够清楚，不要含糊！
+ Array的slice、concat都可以用于clone
+ 对于行为类似的Array但设计不是Array的对象，可以尝试用Array.property.method.call(obj, ...)来访问；比如arguments、NodeList
+ bind支持currying，即除了绑定this外，还可以绑定其他实参
+ 一个技巧：resize会连续触发大量事件，但我们只应该执行动作一次，因此，通过clearTimeout和setTimeout来确保动作只执行一次，在最后一次事件被触发后执行
+ chrome里有profile工具
+ chrome里的window.performance.now提供高精度计时
+ JS源码压缩的一个方法：通过parser将所有变量名替换成短串，根据出现频率来分配串长度，最高频的名字被替换成单字母a,b,c,d等...
+ 用eval可以parse JSON，更严格的应该用JSON.parse
    + 可以用toJSON定义序列化到JSON的方法

#### 10. Haskell趣学指南
+ 1. 简介
    + 纯函数式编程语言 (purely functional programming language)
    + 惰性(lazy)
    + 静态类型(statically typed)
+ 2. 从零开始
    + 内置函数: pred, succ, max, min, +, -, `*`, div, mod
    + 函数声明和变量声明，都是=，区别只是有无参数
    + if e1 then e2 else e3
    + list
        + []为空表，相当于scheme的empty
        + :为插入，相当于scheme的const；而car、cdr则用pattern matching完成
        + `++`连接两个串
        + list `!!` i引用第i个元素
        + [x,y,z]是x:y:z[]的语法糖。这个完全能通过自定义类型(data)来办到！
        + 内置函数: head, tail, last, init, length, null, reverse, take, maximum, sum, elem, sum, product
        + 内置函数: take, drop, takewhile, dropwhile, repeat, replicate, cycle
    + 区间(range)
        + 要求[a]中的a是typeclass Enum的instance
        + [first..last]
        + [first,next..last]，通过first、next可以构造步进
        + [first..]无限列表，利用lazy evaluation的特点
    + list comprehension
        + [x|x<-[1..10]] 单一变量
        + [x|x<-[1..10], x>10] 添加条件(predicate)，也叫过滤(filtering)
        + [x|x<-[1..10],y<-[1..10]] 多变量
        + [[x2|x2<-[0..x]]|x<-[1..10]] 嵌套。非特殊语法
        + [y|x<-[1..10],let y=x*x] 用let引入中间变量，此处非let表达式，其隐含的in是后面及开头
    + tuple
        + list要求所有元素同类型，可变长；tuple允许不同类型，但数量固定
        + (x,y...)
        + 内置函数: fst, snd。再多元素的话，用pattern matching提取
        + 内置函数: zip, zipWith
+ 3. Types and Typeclasses
    + 在ghci中，用:t看类型，用:i看信息，用:k看类型的kind
    + 常见类型: Int, Integer(允许无限精度), Float, Double, Bool, Char
    + Type varaible: 比如 Maybe a, [a]
    + 注意，typeclass只是静态类型的约束，不是实体类，不能用作函数参数、返回值类型
    + 内置typeclass
        + Eq: ==, /=
        + Ord: < <= > >=。另外compare操作Ord返回GT,LT,EQ。Ord是Eq的派生类
        + Show: 允许通过show转换为字符串
        + Read: 从字符串反序列化。使用read时可能需要用::进行类型声明
        + Enum: 可用于[first..last]，每个元素都有successer和predcesor
        + Bounded: 有上下界。可以通过`minBound :: Int`和`maxBound ::Int`来访问
        + Num: 数字特征。一般要求Show和Eq。包含实数和整数
        + Integral: 整数，包含Int、Integer
            + fromIntegral可以将Integral转换为目标类型a
        + Floating: 包含Float, Double
+ 4. 函数的语法
    + pattern matching
        + 语法
            + True/False/1/2/3/"+"等字面值
            + (a,b....)元组
            + (x:rest)列表
            + (constructor a b c d)匹配data的构造器
        + 利用all@(...)的特殊语法来访问匹配整体
        + 对于函数匹配，如果内部用了guard但没有找到对应项，会尝试匹配下个模式
        + case exp of pattern1->... pattern2->...，也是模式匹配
    + guard
        + 语法
            + funcname args | boolexp1 = body1 | boolexp2 = body2 ...
        + 一般最后一个谓词用otherwise，它永真
        + 如果条件未能捕获，则进行下个模式匹配
        + 对比pattern matching和guard，前者用于匹配字面值(常用作递归边界)、拆结构，后者用于匹配区间
    + 用字母定义、调用前缀函数，通过`id`来定义和调用中缀形式
    + 用特殊字符定义、调用中缀形式，通过`infixr 7 +`的形式来指定结合律和优先级；通过`(+)`来中缀访问
    + 关键字where
        + 放在函数尾部，能作用到所有的guard，但只能影响所在的pattern matching
        + 可以从上到下定义多个局部变量/函数(就像scheme的let*)，还可以为变量/函数加类型声明，就像顶层声明一样
    + 关键字let in
        + 是表达式
        + let的出现场合
            + let in表达式
            + list comprehension引入单一值(而非集合)
            + 在ghci中定义顶层变量/函数必须用let
            + do语句中
    + case exp of patterns...
        + 同函数的pattern matching，但是是表达式，可以用在各个场合
+ 5. 递归
    + 例子: 实现maximum, replicate, take, reverse, repeat, zip, elem, quicksort
+ 6. 高阶函数
    + 所有的函数都是curried function
    + 两个primary expressoin之间的空格其实是调用! 即lambda application，且拥有最高优先级
    + 参数不够的情况下，返回partial application
    + 中缀函数可以根据提供的左值/右值生成对应的partial application。用括号括起来的话，按前缀语法来算
        + `-`号要小心，因为`-n`会被当做相反数而非partial application，所以改用`subtract n`
    + flip，交换参数顺序
    + map, filter。尽管都能直接用list compreshension代替
    + foldl, foldr, foldl1, foldr1。后面两个表示初始值直接用第0项
        + scanl, scanr, scanl1, scanr1，类似fold，但是会返回累计的所有元素构成列表。有点像scheme中的stream
    + lambda。语法是\。一般加括号：`(\x y->x+y)`
    + 符号$，优先级最低，右结合，用来简化代码写法，减少括号
    + 符号.，function composition，优先级低，右结合，用来生成新函数
        + point free style(pointless style): 将函数定义改写成无参数的变量赋值，通过连续的.生成partial application
+ 7. 模块
    + 装载
        + import Data.List: 在当前环境中直接可见
        + import Data.List(f1, f2...): 只有f1, f2...可见
        + import Data.List hiding(f1, f2...): 除f1,f2...之外可见
        + import qualified Data.List: 必须通过Data.List.f1来访问
        + import qualified Data.List as List: 通过别名List.f1来访问
    + Data.List
        + intersperse v l2: 将v插入l2的每两个元素之间
        + intercalate l1 l2: 将l1整体插入l2的每两个元素之间
        + transpose: 将list的list转置
        + foldl', foldl1': strict版本(非惰性版本)
        + concat: 连接一组list
        + concatMap: 先map再连接
        + and: list中全为true则true。类似的函数all，接收predicate
        + or: list中有true则true。类似的函数any，接收predicate
        + iterate: 将函数反复作用于上次的结果，产生无穷序列。如`iterate (*2) 1`将生成[1,2,4,8,...]  
        + splitAt, takeWhile, dropWhile. 
        + span，在predicate为false的时候断开链，返回两个链；break，为true的时候断开
        + sort
        + group, groupBy
        + inits, tails. isIndexOf, isInfixOf，搜索一个list看是否包含子list
        + isSuffixOf, isPrefixOf
        + elem, notElem，都返回Bool
        + patition，返回两个list，第1个都符合条件，第2个都不符合
        + find，返回第一个满足条件的结果。返回Maybe
        + elemIndex, elemIndices, findIndex, findIndices
        + lines, unlines, words, unwords: 处理String非常方便
        + nub, nubBy去掉重复元素
        + delete v list: 去掉v的首次出现
        + `\\`集合差集
        + union, intersection, insert：操作集合(有序list)
        + sortBy, insertBy, maximumBy, minimumBy
    + Data.Char
        + isControl, isSpace, isLower, isUpper, isAlpha, isAlphaNum, isPrint, isDigit等
        + genericCategory，接收char，返回枚举，表示Space/Control等类型
        + toLower, toUpper, toTitle
        + ord, chr
    + Data.Map
        + empty
        + fromList, insert, insertWith, null, size, singleton, lookup, member, map, fitler, keys, elems
    + Data.Set
        + fromList, difference, union, null, size, member, empty, singleton, insert, delete
        + isSubsetOf, isProperSubsetOf
    + 建立自己的模块
        + module Name (f1, f2, ...) where
        + module Dir.Name (f1, f2, ...) where：允许层级
        + module Name (Type1(C1, C2), Type2(..), f1, f2, ...) where: 导出类型, 其中Type1(C1, C2)表示为Type1导出C1,C2两个构造子；而Type2(..)表示导出Type2的所有构造子
            + 只导出创建对象的静态函数，而不导出构造子，也是一种风格，只是用户将无法进行模式匹配
+ 8. 构造自己的Types和TypeClasses
    + data Type = Constructor1 ArgT1 ArgT2 | Constructor2 deriving(Eq, Show, Read)
        + 这里的Type只能用于类型的场合
        + Constructor可以用于表达式场合，用于创建Type类型的对象；也可以用于pattern matching的场合
        + 其kind是具体类: *
    + 由于Haskell完备的类型系统，应该和C++一样，不需要携带运行时类型信息，Bool/Int/Float/String等的对象都是纯数据；而Type类型的对象，就是Constructor ID(或者atom) + fields，需要携带Constructor ID用于模式匹配；即类型静态，但constructor动态，对象需要携带用于运行时识别
    + True/False/1/2/3/3.14/1.414/"abcds"/'a'等都相当于是Constructor
    + Just和Nothing是Maybe的constructor
    + data Type a = Constructor1 a Type1 ...: 即data的类型可以参数化
        + 典型的例子是Maybe/Either/[]
        + 其kind是: *->*，即输入一个具体类型返回一个具体类型
    + 可以在data声明前为某个中缀constructor定义`infixr 3 constructor1`
    + 为避免大量的pattern matching来访问字段，提供record syntax
        + data Type = { field1::FieldType1, field2::FieldTyp2...}
        + 然后对于Type类型的对象，可以直接用函数field1、field2访问字段
    + type A = B，即type关键字用于声明别名，比如String就是[Char]的别名
    + 用class TypeClass type where ops来定义新的type class
        + 它只是一种类型约束，描述了generic types应该具有的方法，实际用作函数参数和返回的都是具体类型
        + 函数主要声明函数名和类型签名(type signature)
        + 可以用交叉定义，如`x == y = not (x /= y)`来减少类型实例实际应该实现的方法
            + instance类型必须定义的最小方法集合，叫minimal complete definition
    + 对于内置type class，可以直接deriving来实现
    + 对于其他type class，用instance TypeClass Int where ops来实例化，Int类型的哪一组函数实现了该type class
    + 注意区别，[]是一个variadic type, 而Num是一个typeclass；[a]是一个具体类型(kind为`*`)，而Num a只是一个类型约束声明
    + 可以用cons/car/cdr定义出自己的list，而使用起来(包括模式匹配)却几乎像[]一样方便!
    + 考虑实现一个针对任意内置类型的toBool函数，输入False/0/[]/Nothing返回False，其余返回True:
        + Haskell是静态强类型的，完全没有类型泄露，因此，必须想办法把Bool/Int/String/[]等具体类型携带到toBool的参数
        + 有两个办法:
            1. 声明typeclass ToBool，每个具体类型去实例化它，实现ToBool的接口toBool
                + 该方案其实是实现了重载的多个版本的toBool，针对每个类型，都有一个专门的函数toBool
            2. 声明data ToBool，利用Constructor(或者说运行时type tag)来区别各个类型，然后以ToBool作为toBool的参数，通过Constuctor进行匹配...
                + 该方法的缺点是，必须`toBool (FromInt 3)`；而如果要透明的`toBool 3`，其实又需要typeclass了(输入typeclass, 输出带constructor的data type)...总之，这是个思路
    + 一个案例Functor typeclass，它实例化的不是具体类，仍然是参数类，kind是`*->*`
        + Functor可以作用域[]/Maybe/Either等
    + 对比C++
        + struct Vector {float x; float y; float z;}   
            1. data Vector = Vector Float Float Float
            2. data Vector = Vector { x::Float, y::Float, z::Float}
        + enum Weekday { Monday, Tuesday};
            1. data Weeday = Monday | Tuesday
        + tagged union: struct Variant { int type; union{ int i; float f; char *str; };};
            1. data Variant = FromInt Int | FromFloat Float | FromStr String
            + 注意这里用FromInt等constructor ID来代替type tag
        + polymorphism: struct IShape{}; class Rect: public IShape{}; class Circle: public IShape{};
            1. data Shape = Rect Float Float Float Float | Circle Float Float Float
            + 这里同样利用Rect/Circle等constructor ID来代替运行时类型信息
    + 编译期多态用typeclass(重载，等同于C++的模板); 运行时多态用data，用constructor作为类型信息，用pattern matching进行类型分派；如果实在需要可扩展的多态，那么，用Associative array等做类型映射吧
9. IO
    + main函数的类型是 IO ()，表示返回空tuple的IO action；getLine是IO String，即返回String的IO action
    + 从main函数出发的IO action构成了一棵树(do关键字可以携带子树, AST)，解释器只会求值树上的语句。换言之，只有从IO action可达的语句才会被force求值，而其他语句则被lazy放过
    + do关键字可以将多个IO action打包成一个IO action。这里的子IO action可以包括
        + getLine, putStr, putStrLn等内置函数
        + 类型为IO()或者IO a的自定义函数，如main
        + 在do语句中，要从IO action中取值，用`name <- ioaction`
        + 在do语句中，用声明中间变量，用`let name = expression`
    + 要从形如IO a的IO action中取得值a，需要name <- ioaction
        + 如果手误写成 name = ioaction，其实这是又声明了一个类型为IO a的变量
    + return关键字，以表达式构造一个IO action，供外层函数<-，或者作为程序返回值
        + 它只是一个普通的类型为IO a的表达式，不带跳转语义(不是控制流)，所以应该作为tail call。出现在do中段的return看起来会很奇怪，因为实际上不会跳转...
    + do将源码级的多个IO action打包，而sequence将运行时的一组IO action打包，即输入[IO a]返回IO a
    + mapM f = sequence . map f
        + mapM是先map再sequence打包IO actiion的惯用法
        + forM和mapM一样，只是参数顺序不同，第1个参数是列表，第2个是将元素映射为IO a的函数
    + 其他几个函数
        + when函数。出自Control.Monad
        + forever，出自Control.Monad。循环执行一个IO action
    + Lazy IO
        + getContens，从标准输入中返回所有内容，但是是惰性的，所以可以利用输入缓冲。结合lines、words等函数威力强大
        + interact，接收一个函数，传入所有的标准输入字符串，返回IO a。常用
        + openFile -> hGetContents -> putStrLn -> hClose
            + IO相关的函数都有对应的hXXX版本, 如hGetLine, hGetChar, hPutChar, hPutStr
        + withFile，类似interact，不过可以指定文件，它隐藏了文件的打开关闭，直接传给回调文本内容
        + readFile, writeFile, appendFile, 直接传入路径，返回或写入字符串(当然要用<-提取返回值)
        + hSetBuffering, hFlush
        + openTempFile, removeFile, renameFile
    + 命令行参数
        + System.Envrionment
        + getArgs, getProgName
    + 伪随机数
        + typeclass RandomGen是随机数发生器, 而typeclass Random可以是各种Num类型
        + 可以用mkStdGen创建一个类型是StdGen、满足RandomGen的发生器
        + random，输入一个RandomGen(比如StdGen类型)，返回Random约束类型，如果分别用::Int, ::Bool, ::Float，可以分别返回不同类型的随机值
            + random同时还返回一个新的RandomGen，因此，RandomGen其实是函数式结构
        + randoms，根据一个RandomGen生成无限随机序列
        + randomR，可以指定一个tuple作为上下界，结果将在这个范围内随机
        + randomRs, 生成指定范围的无限随机序列
        + getStdGen，返回一个全局变量的StdGen，每次启动程序的时候都会不同
        + newStdGen，创建一个新的StdGen，同时还会更新全局StdGen，影响getStdGen的返回值
   + Bytestrings 
        + 在IO的时候，输入输出String这个惰性list，性能太差，因为相当于每个字节都有一个thunk，作为选择，可以改用Data.Bytestrings或者Data.Bytestrings.Lazy，前者是完全非惰性的，完整的加载进内存，后者是以64K为thunk单位的部分惰性数据结构
        + Data.Bytestrings以及Data.Bytestrings.Lazy中有IO相关的全套函数
            + 比如readFile, writeFile等
        + 当IO规模很大的时候，逐字节的lazy不划算，考虑用Bytestrings，可能有显著的性能上的提升
        + pack, unpack, 在Bytestring和Word8的[]间转换
        + fromChunks, toChunks，在惰性和strict版本间转换Bytestring
        + Bytestring有Data.List相似函数，比如head, tail, init, null等
    + Exception
        + 在pure functinal部分，建议用Maybe、Either来进行异常处理
        + doesFileExist可以判断文件存在
        + 在IO部分，用catch来处理异常
            + 可以用isFullError, isEOFError等谓词来进行异常过滤
            + 可以用ioeGetFileName从异常中抓取文件信息
            + 用userError、ioError来重新抛出异常
10. 函数式地思考来解决问题
    + 逆波兰求值器，能求值"2 3 * 4 -"
11. 函数式地思考来解决问题
    + Algebraic data types和typeclass，分别可以提供runtime polymorphism和compile time polymorphism
    + 所谓Functor
        + map/filter/fold可以用在[a]上，极有威力，能不能将这组操作延伸到任意类型呢？即将map/filter/fold作用到`F a`类型上? Functor、Applicative Functor、Monoid(针对mappend操作)、Foldable，就是干这些事的
        + Functor，就是指可以被应用map操作的类型，即，凡是能被map over的类型，就可以通过实例化(instance)Functor这个typeclass，来实现对fmap的支持
            + 在C++里，要实现fmap函数对不同类型进行不同操作，其实就是template specialization；在Haskell里，一个函数只能声明成针对约束类型(即参数类型是某typeclass的实例)的操作，如果要进行特化，那么，需要声明一个新的typeclass，将操作声明为typeclass的method，最后，不同类型分别去instance这个typeclass以实现函数的overload(或者说，类型的polymorphism)
        + Haskell中，用`f <$> obj`来表示将类型为`a->b`的函数f应用到类型为`F a`的对象obj上，返回值的类型为`F b`
        + 应用在函数上，等价于function composition
        + Functor laws
            1. 对一个Functor做fmap id，结果应该等于原Functor
            2. `fmap (f1 . f2) functor`，结果应该等于`fmap f1 $fmap f2 functor`
            + 一个简单的Functor laws的反例: Functor类型是`F Int a`，其中Int用来记录fmap被应用的次数，这样，该Functor有了状态，并会随fmap改变，所以破坏了Functor laws
    + 所谓Applicative
        + Applicative的目的是，在Functor支持的单参函数的map基础上，支持多参函数对任意类型的应用，比如，将`a->b->c`应用到`F a`和`F b`上返回`F c`。方法是，利用Haskell默认的curring特性，实现`F a->b`应用到`F a`返回`F b`
        + Applicative的操作符是<*>，常见用法是`(+) <$> Just 2 <*> Just 3`
        + 利用Applicative，对Maybe/List Functor等应用多参函数，相当于归并多路数据；如果对一组function Functor应用多参函数，会返回新函数，新函数现将参数分流到多路function Functor上，最后再利用多参函数汇总
        + 对List Applicative应用多参函数，很容易实现list comprehension的效果
            + 注意list comprehension的枚举list个数是编译期的，利用递归，我们可以做到运行时的枚举个数。比如permutation、combination、queens算法，既可以使用两项的list comprehension，也可以使用两参数的applicative style
            + 借助ZipList这个newtype，可以在applicative style中进行zipWith操作而非list comprehension
        + 在不拆包的情况下对容器类型表达式进行<$><*>的编码风格，叫做Applicative style
        + `liftA2 f a b`等价于`f <$> a <*> b`
    + 利用Functor、Applicative，很容易对任意类型应用操作，而不需借助模式匹配拆包
        + 换句话说，对Functor、Applicative应用单参、多参函数，输入、输出在原容器类型空间(即输入输出都在`F a`中的F中)。有没有看到Church numeral时的似曾相识感觉?
        + 用在Maybe/IO上特别方便！
    + data vs type vs newtype
        + data可以创建任意类型(用C++的观点来看，其实就是tagged union，其中constructor就是tag，而后缀的字段部分，是union)
        + type仅仅是为一个已有类型提供别名，文本级别的，对type system完全透明，即不会在类型系统中引入新类型(用C++的观点来看，就是typedef)
        + newtype，引入编译期类型，该类型仅存在于类型系统中，运行时完全透明，等价于原类型。目的是，让同一类型能够重载一个typeclass多次，分别提供不同实现；即完全是为了重载引入的机制
    + 所谓Monoid
        + Monoid是指针对某项操作满足结合律并且有一个0元的类型
        + 支持mempty和mappend两个操作，任意类型如果支持两个值的叠加，都可以instance Monoid的实例
        + 借助Monoid，可以通过foldMap实现fold
        + 常见的实例包括[a]、Sum a、Product a、Any(描述两个Bool结合的方式)、All、Ordering(a==EQ则返回b，否则返回a，用于字典序比较等)等
12. 来看看几种Monad
    + 所谓Monad
        + Monad本意是为了给表达式中的值附加隐藏属性(计算上下文，ctx)，从而给计算提供额外可能；而不同的计算方式，通过类型来区别，每种类型通过instance一个Monad的实例，从而实现不同的计算方式
        + 在一个Monad computation序列中(通过>>=和>>连接，或者作为do notation中的语句)，拥有额外运行属性的值，叫做monadic value；特定序列中，monadic value的类型是固定的，在这个上下文中的其他类型都是非Monad类型(尽管在另一个计算中该类型可能作为monadic type)，不会有隐藏属性
        + 在特定序列中，针对非monadic value类型的操作，用空格、`$`、`.`来连接operator和operand；而针对monadic value的操作，要用<$><*>连接；对monadic value的操作，需要在该Monad类型的instance中定义隐藏属性的结合方式
        + 可以用return来将非monadic value转为monadic value，用<-来将monadic value转换为非monadic value
        + 一个`>>=`、`>>`序列的返回类型就是Monad类型；而do notation经过CPS变换后，也就是一个>>=序列，因此，一个do表达式本身也就是一个Monad类型的值
        + 相比普通的表达式计算，Monad提供了两种额外的能力
            1. Flow control的能力；因为`>>=`运算符其实是将前一个计算的结果应用到后续计算的continuation上，所以，通过不同类型的Monad实例，就可以提供不同的continuation的操纵方式
                + 比如，Maybe monad和Either monad(Error monad)，可以根据ctx的状态(即Monad类型的constructor)，判断是否还需要继续后续计算，它允许直接抛弃continuation从而结束后续计算；这实现了异常的控制流
                + 比如，List monad，可以将先前计算的所有结果，依次应用到后续计算上，从而提供non-deterministic的能力
                    + 还可以有其他变化，例如，简单的给每个可能值附加概率属性，只将概率大于0的值传给后续计算...
            2. 访问隐藏属性的能力
                + Maybe/Either/List monad的kind都是`*->*`，所以其隐藏属性是无状态的，而如果一个Monad的类型是`*->*->*`的话，那么其隐藏属性还可以持有状态，该状态可以被访问，包括读、写、读写访问
                    + 严格的说，Maybe/Either/List类型也是有状态的，只不过状态有限，只包括其constructor的枚举值；比如Maybe monad就是通过其constructor的枚举值来决定是否应该继续计算
                + 隐藏属性的只写能力(Writer monad)
                    + 该Monad类型至少应该是`F s a`，其中s是状态类型。于是`>>=`的类型就是`F s a -> (a -> F s b) -> F s b`。由于是只写，后续计算的continuation无需读隐藏属性，只需要输出隐藏属性，因此，在Writer monad的`>>=`实现中，只需要决定前导计算结果中的状态s1和continuation的输出中的s2，怎样结合到最终的monadic value中，默认的结合方式是mappend。
                    + 可以用于log等输出，比如记日志、记录函数调用次数等
                + 隐藏属性的只读能力(Reader monad)
                    + 该Monad类型至少应该是`F s a`，其中s是状态类型。由于`>=`的实现中，只能将值类型a传给continuation，没能显示的将状态一并传递，因此，要让continuation中的计算能够访问状态，只能是让continuation返回一个新函数，由该函数来接收隐藏状态作为参数，而该函数体中包含了后续计算的逻辑；由于隐藏状态不会更新，所以该函数的输出可以只是值类型b。因此，continuation的类型声明应该是`a -> s -> b`，而continuation的类型又在`>>=`中声明为`a -> F s b`，因此可以判断Reader monad的类型`F s a`应该是`s -> a`，即Reader monad应该是一个函数，它接收状态s并返回值a
                    + Reader monad其实只是隐藏了只读的状态，在计算能力上和为函数显示声明一个状态参数没区别，所以一般可以直接多声明一个状态参数来替代Reader monad的使用
                + 隐藏属性的读写访问能力(State monad)
                    + 在pure functional的环境中，更新一个状态，是通过输入旧状态并返回新状态来做的，即updateState操作的典型类型是`s -> (s, a)`
                    + 在ReaderWriter monad中，`>>=`的continuation需要访问状态，基于和Reader monad同样的理由，该continuation接收值类型a后应该返回一个函数，这个新的函数应该接收状态s并进行读写访问，由于状态可能更新，所以该新函数应该返回输出值和新的状态，于是，continuation的类型应该是`a -> s -> (s, b)`，由`>>=`的类型声明可以推断，ReaderWriter monad的类型`F s a`应该是`s -> (s, a)`，即他是一个函数，接收旧状态，输出值和新状态
                    + 在纯函数环境中，最繁琐的就是用immutable的数据结构来表达mutable的逻辑，因为这将涉及显示的状态更新和传递，而ReaderWriter monad通过将可更新状态类型隐藏起来，将状态的更新和传递动作放到`>>=`中，从而极大的简化了状态操作代码，提高了代码的可读、可维护性
                        + 这个动作用王垠`wired`、`wireless`的比喻来说，就是，纯函数中状态的更新、传递代码，被作为导线从地上埋到了地下(隐藏到了`>>=`中，也就是do notation的行与行之间)
                    + ReaderWriter monad可以被用来实现作用域，如this、global等，及其强大
                        + 用来隐藏随机数发生器
                        + IO monad可能也可以被实现为State monad
    + In functional programming, a monad is a structure that represents computations defined as sequences of steps. A type with a monad structure defines what it means to chain operations, or nest functions of that type together. This allows the programmer to build pipelines that process data in steps, in which each action is decorated with additional processing rules provided by the monad.[1] As such, monads have been described as "programmable semicolons"; a semicolon is the operator used to chain together individual statements in many imperative programming languages,[1] thus the expression implies that extra code will be executed between the statements in the pipeline
    + Many common programming concepts can be described in terms of a monad structure, including side effects such as input/output, variable assignment, exception handling, parsing, nondeterminism, concurrency, and continuations. This allows these concepts to be defined in a purely functional manner, without major extensions to the language's semantics
    + 在Monad的计算序列中(>>=和do notation)，如果pattern matching失败，会调用Monad instance的fail
    + guard的类型是`(Monad m) => Bool->m`，在为True时返回空tuple的Monad(即`F ()`)，为False时返回fail；一般它被用于控制continuation
        + 当guard的predicate为False时，在Maybe/Either/Lis monad中，都会返回对应的中断控制流的monadic value
    + do notation的展开过程(CPS变换)
        + 将let的赋值号左边的ID和do剩余的语句组成一个函数(类型是`a->F b`，即>>=中的continuation)，以let赋值号右边的实参调用它。使用空格而非>>=调用，因此该行CPS不受>>=调度
        + 将<-左边的ID和do剩余的语句转换成一个continuation函数，以<-右边的表达式调用它，用>>=来调用。这里会应用monadic type定义的continuation控制，以及隐藏属性的更新、传递
        + 将`expression`的行(常见的是guard和tell等输出函数)，转换为`expression >>= (\_ -> ...)`。即，尽管continuation不会关心传递的值内容，但传与不传，还是重要的，这决定了continuation是否会被驱动，在Maybe/Either/List等Monad中比较明显。
    + Monad laws(单子律)
        + left identity: `(return x) >>= f`应该等价于`f x`。用monadic function来说，即`return <=< f`等价于f
        + right identity: `m >> return`(这里的m是monadic value)应该等价于`m`。用monadic function来说，即`f <=< return`等价于f
        + associativity: `(m >>= f) >>= g`应该等价于`m >>= (\x-> f x >>= g)`
            + 这意味着>>=满足结合律，所以直接使用>>=构造的左结合序列，和使用do notation的右结合序列，是等价的
    + monadic function composition: `<=<`
        + f <=< g = (\x -> f x >>= g)
    + Monad中的flow control、隐藏属性结合点，在`>>=`，或者说在do notation的行与行之间；因此do notation的行也就是属性访问、控制流的最小单元
13. 再来看看更多Monad
    + Monad利用>>=和do notation来减轻我们对context的关注，而将精力放在value本身
    + 利用difference list来确保FP风格的linked list总是从后往前append(因为append每次会拷贝整个a链，因此在连续的append中将a链长度控制k而不是n，避免了算法空间复杂度退化到n^2)
        + 经测试，在Haskell中效果显著，而在Racket中效果不明显，为嘛？
    + 一些实用的monadic function
        + liftM: 相当于fmap，但不依赖于Functor的定义
        + lifetM2: 相当于liftA2，但不依赖于Applicative的定义
        + join: 用来减少context层次，减少层次的同时令外层的context和内层结合。用于List就是concat，用于Maybe/Either/Writer/State的时候...
        + mapM, forM:
        + filterM:
            + 一个典型用法, `filterM (\x->[True,False]) [1..3]`，就可以生成集合的所有子集啦
        + foldM:
    + 利用Maybe/Either monad进行错误处理. 书中的例子:
        + 走钢丝
        + Reverse polish notation中的错误处理，包括read失败、pattern matching失败等
14. Zipper数据结构
    + 在纯FP中，对一个数据结构的任何一点的修改，都会生成一个新的结构(比如binary tree的insert会生成O(log n)个新节点)，而根据special locality原理，接下来的修改很可能还在上次修改点的附近，于是有了Zipper手法在FP语言中的应用
    + Zipper是一个pair，保存了结构的当前子结构，以及遍历信息(用于重建)；利用子结构和遍历信息，你可以继续任意方式的遍历、修改以及重建，这种手法降低了摊还的深访问、修改&重建开销
    + 考虑binary tree的zipper
        + 不使用Zipper，k次读开销是O(k * log n)；k次写的时间开销是O(k * log n)，空间开销是O(k * log n)
        + 使用Zipper，k次相邻位置读的开销是O(log n + k - 1); k次相邻位置写的时间开销是O(log n + k - 1)，空间开销是O(log n + k - 1)
    + 书中的例子(注意这里的错误处理又用了Maybe monad)
        + binary tree
        + list 
            + 文本编辑器，一个line list，可以定位到某行，删除、添加、修改当前行。如果用IP中的array+index来访问，显然，增删就没有那么高效了
        + file system tree

#### 15. 杂项
+ Haskell
    + SPJ的说法：在OO中，设计是画UML图；在Haskell中，设计是写类型签名
    + 在类型声明中，(->)是一个type constructor，具体来说是函数构造子，它有两个参数，实参类型+返回值类型(返回值可能是另一个函数，即另一个(->)构造子)
    + (,)、(,,)都是tuple的构造子，是函数
    + list comprehension，只不过是List monad的语法糖，等价于do notation + guard(用作filtering)
    + 记住，Monad不过是一个typeclass，monadic value的类型本质上还是Maybe/Either/List/Writer/Reader/State/RWS等
    + RWS monad
        + 显然，其中的R意义不大，而WS可以用(W,S)来替代，因此RWS可以用State monad替换。单独提供一个RWS monad可能是出于使用方便的需要
    + FP中的immutable data structure，由于总是创建新结构而不改变老结构，可以用来做版本控制
+ 注意在FP中，当输入输出都是list的时候，考虑concatMap，即list comprehension
