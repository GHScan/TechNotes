#### 9. 杂项
+ 关于GC
    + .Net的Generational GC第0代默认选择256K，因为这是L2的大小
    + JVM的分代GC概念
        + 三代
            + Young generation
                + Eden, 空间x8
                + Survivor from, 空间x1
                + Survivor to, 空间x1
            + Old generation
            + Permanent generation
        + 分配的时候，在Eden和Survivor from上，一旦满额，就应用Copying GC的机制拷贝到Survivor to中，如果Survivor to空间不足，则拷贝到Old generation中。典型的，Young generation的一次GC希望回收90%
        + 如果只对Young generation回收，则称为minor GC；否则称为major GC或full GC
        + Old/Permanent generation对Young generation的引用通过card table来标记
+ 几种GC的对比
    + mark and sweep
        + 复杂度：标记阶段是O(a)，这里的a是活跃对象；清扫阶段是O(n)，需要遍历每个对象
        + 指针不被搬移，地址稳定，可以利用memory pool，比如tcmalloc
    + copying gc
        + 复杂度：O(a)，只处理存活的对象。因此对于第0代这种回收率极高的场合，非常适合
        + 指针搬移，GC完毕后需要更新所有对象、以及栈上寄存器/临时变量中的的指针；或者总是用Handle来访问
        + 分配迅速，只是freeOff的加法
    + mark and compaction
        + 一般4趟：
            1. 根据reachable graph，遍历标记
            2. 遍历整个堆，为每个存活对象计算新地址，保存在对象头的forward字段中
            3. 遍历整个堆，对于每个存活对象，遍历其中的每个引用字段，将字段值替换为旧指针对应的forward值
            4. compaction
        + 复杂度O(n)，因为需要多次遍历所有的块
        + 指针搬移
        + 分配迅速，加法
+ 对于variant/any/object的概念，常见的实现方案包括，tagged union和tagged pointer，以及object指针
+ C++中的转型
    + 对于有符号、无符号，姑且允许直接用C-style转换
    + 对于class/struct指针，一定要用`static_cast`等C++-style转型，因为后者包含了更多的类型信息，可以在编译期检测出逻辑错误
        + 比如，对于A和B这两个类型，你期望他们有继承关系，所以用`static_cast`来处理指针转换，但由于人为失误，他们没有继承关系，这时，C++编译器会检测出该`static_cast`使用非法；如果你确实要在两个没有继承关系的指针间转型，就应该确实的使用`reinterpret_cast`。此为利用类型信息发现逻辑错误的典型
+ 在Scheme解释器中统一数据和代码的方式(跟quote有关)
    1. 代码和数据是同一格式，比如用Scheme、Python来写解释器，代码和数据都用list表示。浓浓的FP味儿
    2. 代码是经过词法寻址后的优化形式，而数据是纯粹的列表，(eval (quote ...))的时候，需要将列表编译优化过的代码形式。实际的高性能解释器方案
+ 关于实现Scheme解释器的几个层次
    1. 递归解释器，宿主语言(解释器的实现语言)不支持尾调用优化(如Python/C#/Javascript): Scheme程序轻易栈溢出(尤其考虑到Scheme中用递归表达循环的风格)
    2. 递归解释器，宿主语言支持尾调用优化(如C++/Lua)，或者将eval手工改为尾递归优化形式(修改eval参数后goto到函数开始): Scheme程序中的尾递归函数不再栈溢出，但大量的非尾递归仍然溢出(如cons)
    3. 递归CPS解释器，或者用普通的递归解释器解释经过全文CPS变换后的Scheme程序：不再有栈溢出
        + 这里有一个考虑，用户自定义函数肯定是CPS风格了，那内置函数呢？DS风格？慢了。如果内置函数和自定义函数都需要作为高阶函数传给map等函数作为参数呢?
    4. 字节码解释器，使用ADT的stack来实现脚本栈而不再是复用native栈：不再溢出
        + 在输出的字节码中插入tail指令，进行tail call optimization，性能提高显著
+ Python的tuple赋值左端，可以当做一个简单的模式匹配器使用
+ 关于VCPS
    + 用于做迭代器很方便
    + 对于递归CPS解释器来说，要求宿主语言支持尾调用优化，如果不支持的话，如C#，就需要写成VCPS风格。但其实无需全文都写成VCPS风格，只需要在几个关键点，如求值application时将最后一步apply给换成(cons args k)即可
        + 经实测，这将VCPS的中间pair结构数量下降到1/4
+ 全文CPS变换程序中用到的CPS本身的一个技巧：
    + k(result)的返回值仍然可以进一步处理！即还可以包裹一层ctx！如(ctx (k result))
    + 合理利用k的返回值，在特殊场合下可能大幅简化程序！
+ 4类lambda环境模型
    1. 堆环境：如Scheme、Javascript的原始模型
        + 调用一个函数的时候创建一个新环境块儿，所有局部变量都放在里面；在该作用域内创建函数时，会保存整个局部环境作为free varaible寻址用
        + 没有块级作用域
    2. 堆变量
        + 每个局部变量都是Ref<object>的引用，创建函数时，函数会引用它以及它内嵌的子函数需要的free varaible的Ref<object>引用。Ref<object>通过引入了一个间接层，让局部访问以及free variable访问都能共享的作用到其他作用域，因为只保存了一份数据，所以所有引用总是同步更新
        + 支持块级作用域
        + 相当于lua模型的一个简化
    3. 栈环境+堆环境：如C#的lambda
        + 分析局部变量中会作为free varaible被引用的集合，在进入函数体过后就创建heapEnv对象，对于非free varaible局部变量，总是通过stack[i]来访问，而对于会被内层引用的变量，总是通过heapEnv[i]来访问。创建函数的时候保存heapEnv对象。
        + 该方案比堆环境模型更优化，但同样不支持块级作用域
    4. 栈变量+堆变量：如Lua
        + 局部变量放在栈中；当创建函数时，对于函数及内嵌函数需要引用的free varaible，创建upValue对象，其内包含一个局部变量地址；当退出作用域时，利用close指令，将当前深度的作用域对应的所有的upValue给close掉，即将栈指针指向堆中
        + 支持块级作用域
+ 对于不支持块级作用域闭包的语言，如Scheme、C#
    + Scheme中的循环是递归风格，总是创建新环境，块级作用域的问题不明显
    + 对于C#、Go、Javascript，总是可以通过`(function() {})()`来模拟块级作用域。尤其是在动态语言/类型推导完备的静态语言中特别好用
+ 在一个经过CPS全文变换的程序中，有两类函数
    1. 原始代码中的函数，现在全为CPS风格，即总有一个k参数
    2. 变换引入的k函数。原始码中透明、无法访问
+ 递归的数据结构还是递归算法最自然
    + 比如parser
    + 比如迭代
+ C/C++的实参求值顺序不定！
+ 在一个Copying/Compaction GC系统中，保存裸指针是危险的，除了应该确保指针可达外，还应该总是通过类似Handle的间接层来访问指针
+ 加速解释器一个方法是为常用操作提供专门指令、降低解释开销。如
    + load0, load1, loadnil
    + loadlocal0, loadlocal1, loadfree1, loadfree2
    + tjmp, zerojmp, niljmp, eqjmp, lessjmp
    + inc, dec
+ 字节码解释器中，也可以将callstack隐式的放入evalstack中
+ 关于yield、async/await，可以通过实现first class stackframe来实现
    + 需要提供的支持:
        1. 原语stackframe: 利用函数对象及实参，创建stackframe对象
        2. 原语yield: 将callstack顶上的stackframe弹出
        3. apply时除需要支持native function、script function，还需要支持stackframe对象作为operator
    + 在该机制下，(+ 2 3)等价于((stackframe + 2 3))；对于不包含yield的函数，后者等价于前者，如果包含yield，那么就不同了，可以先(stackframe f 2 3)得到stackframe对象，再多次apply
    + 相对的，coroutine需要first class stack的支持。
+ 关于抽象解释
    + 将值域缩小到特定范围后的解释过程
    + 例子
        + 编译。环境是符号表，值域是代码
        + 静态分析。环境是符号表，值域是类型等规则
        + 类型系统。环境是符号表，值域是类型
        + 正负号的求值系统。环境是符号表，值域是+-0
        + 解释代码求evalstack深度。环境是符号表，值域是深度
        + CPS变换：环境是上下文，值域是变换后的代码
        + 寄存器分配: 环境是寄存器使用上下文，值域是寄存器名
+ 关于dynamic scoping
    + 作用域查找，即确定变量在哪个作用域，叫scoping
    + 作用域查找即变量位置查找，叫addressing
    + 所谓lexical adderssing，是指能够通过源码推断出变量的地址，即编译期寻址。是一种eager binding
    + dynamic scoping，是指在运行时进行变量定位，分两种:
        1. 基于execution context查找。这里的execution context即env chain。比如Javascript的with
        2. 基于calling context查找。即基于调用栈帧查找。比如Common lisp中的dynamic scoping
+ 在支持first class function的语言中编写递归，应该注意避免函数体依赖函数名，特殊用法除外(如memoize)
    + 对于javascript，有named function expression
    + 对于scheme，有named let；其他语言类似
+ Javascript经验
    + 少用for-in
        + 基于prototype的OB/OO用法，for-in会遍历prototype中的类方法，多半不是你想要的结果。必须结合hasOwnProperty
        + 用for-in遍历数组很慢，得到的索引i甚至可能是字符串！
    + 对于值类型Number/Bool，尽量不要扩展prototype，因为2.method可能会被处理成new Number(2).method，而2 === new Number(2)是false的，所以会有坑...
    + 在JS这种语言中，应该逆向遍历
        + a.length如果作为结束条件，那么每次迭代都要进行属性访问，哪怕是inline caching，都会更慢
        + 如果遍历的是IE中的NodeList，那么a.length是COM对象的属性访问，超慢...
    + Douglas Crockford的JS编码建议
        1. 只用===和!==，而不是==和!=
        2. 不用with。它会破坏lexical addressing，在v8中测试，会比普通的属性访问慢几百倍
        3. 小心eval，它有性能问题和安全问题
        4. 总是使用function expression而不是function declaration，因为后者会自动提升，可能成为坑
        5. 永远不要出现new String(), new Number(), new Boolean(), new Object(), new Array()
    + 总是使用'use strict'
+ npm install -g pkgname可以安装包到全局；再通过npm link pkgname加到本地供require

#### 9. Javascript高级程序设计，读书笔记
+ ECMAScript的诞生是因为浏览器厂商的竞争，多个Javascript的行为不一致导致上层开发困难，才标准化
+ ECMA-262定义的ECMAScript与Web没有依赖关系，它只定义了语言的基础，不包括IO。常见的平台包括：
    + Web。DOM+BOM
        + DOM的标准化也是因为IE和Netscape关于DHTML的竞争
            + DOM1: XML和HTML
            + DOM2: 鼠标和UI事件、范围、遍历、CSS、视图
            + DOM3: DOM文档的加载和保存；DOM验证
        + 还有几种对应DSL的DOM标准
            + SVG
            + MathML
            + SMIL
        + BOM本身没有标准，只能针对浏览器适配。HTML5解决了这一问题，包括操作浏览器窗口和cookies等功能
    + Node
    + Adobe flash
+ `<script>`标签最好放到body最后，这样，加载script之前可以先显示其他元素，而不至于空白
+ 外部`<script>`的优点:
    + 可维护。比如版本控制
    + 浏览器可缓存，避免重复下载
    + 不需要内部`<script>`的一些注释hack等(比如<到底应该被当做小于还是tag的一部分)
+ JS编码风格
    + 用''来表示字符串。这样，JS代码片段可以被插入html属性的""中
    + 总是用`;`而非换行来分割语句，为了JS源码可压缩(移除空格和换行)。也算是对运行时JS parser性能有所帮助
+ DOM、BOM中的对象都是宿主对象，其行为不受ECMA-262约束。比如IE中的DOM对象就是COM
+ ECMAScript的Number是IEEE754规定的双精度浮点，但bitwise op是作用在32bit整形上的，JS解释器自动转型
+ JS和Java一样通过>>>和<<<来处理逻辑移位
+ 引用未定义变量会抛错，但if/短路逻辑中的未定变量引用，只要没执行就不抛错
+ 没有goto label，但是有break label、continue label
+ 关于属性枚举
    + obj.hasOwnProperty(), Object.keys(), Object.getOwnPropertyNames()，访问的都是instance proprety
    + for-in, in访问的是instance + prototype的property
+ JS的switch相当于if/elseif，因此case中可以出现任何类型和表达式(甚至是运行时表达式)
    + switch的case匹配用的是===
    + switch(true)，然后每个case都是test，是典型用法，用来代替if/elseif列表
+ 总是可以用arguments来访问实参；如果形参太多，那么多余的形参是undefined
+ 没有返回的函数，实际返回undefined
+ String是基本类型，不是Object的派生，因此不能添加属性
+ typeof和instanceof
    + typeof依据type tag，可以识别基本类型和object；虽然function实际上是一种callable的object，但为了方便使用，会返回'function'
    + instanceof依据prototype chain，而对象隐藏的prototype，是在new时绑定的。因此instanceof多用于OO
+ ECMAScript的全局环境，在Web上可以通过window来访问，在Node中通过global访问
+ 注意字典literal也是在new Object，因此它的prototype就是Object.prototype
+ object的属性名总是string
+ 在API设计中，可以用字典来整合optinal参数
+ a.length = n；可以直接扩展/收缩数组
+ 如果存在多个window/global对象的话，instanceof用来判断Array/String/Date就不靠谱了，所以应该用内置函数Array.isArray, Date.isDate等
+ Array.prototype.sort默认是基于对象的toString比较，因此一般都应该传入特殊的比较器
+ JS中没有块级作用域，var声明都会自动提升，效果等同于C语言中只能在函数开始声明所有变量
+ 写递归时，通过arguments.callee来递归比直接引用函数名或者function expression名字要慢很多
+ this是lexical addressing的，它和arguments一样，是隐含参数。如果调用方不是dot expression的话，函数体中的this就被初始化为window(严格模式中是undefined)
+ 严格模式下不能访问arguments.caller是出于安全考虑，避免访问调用方的源码字符串
+ eval访问的是全局环境(window/global)
+ Object.defineProperty访问属性，可以定义writable，getter/setter等
+ Object.preventExtensions禁止添加属性；Object.seal，进一步，禁止修改property的属性；Object.freeze，再进一步，不允许写属性值
+ 构造函数也只是普通函数，如果不用new而是直接调用，结果是将属性绑定在了window/global对象上
+ 对象内部持有的是new时刻的prototype，因此修改旧的prototype对象，对象行为改变；而修改构造函数的prototype属性，早创建的对象不受影响
+ 闭包实现的OO有属性的受限访问这个好处
+ JS中的常见对象模型
    + OB：设置构造函数的prototype，然后new
    + OO: 将派生类的构造函数的prototype设置为基类的对象，或者从基类构造函数的prototype中Object.create出来；派生类的构造函数要base.call(...)来初始化基类属性；最后new
    + Object.create，访问链，有点像运行时的with
+ JS的声明提升和Scheme中的不一样，前者相当于语句直接出现在了函数开头，而后者是被define被拆成了开头的define以及后面的set!；从正确性上来说，后者更容易理解，没坑
+ JS不支持块级作用域；但似乎全局环境下的块却是有局部作用域的...
+ JS中obj.method返回的不是bound function，需要手工bind
+ module模式很常见，避免了全局名污染
+ 引用没有声明的全局变量会抛错，但是window.name却只是返回undefined
+ 如果允许注册回调，不应该用callback != null来判断，而应该typeof callback == 'function'；即，总是用typeof/instanceof来确认变量是你要的；更进一步说，想要什么，要说明的足够清楚，不要含糊！
+ Array的slice、concat都可以用于clone
+ 对于行为类似的Array但设计不是Array的对象，可以尝试用Array.property.method.call(obj, ...)来访问；比如arguments、NodeList
+ bind支持currying，即除了绑定this外，还可以绑定其他实参
+ 一个技巧：resize会连续触发大量事件，但我们只应该执行动作一次，因此，通过clearTimeout和setTimeout来确保动作只执行一次，在最后一次事件被触发后执行
+ chrome里有profile工具
+ chrome里的window.performance.now提供高精度计时
+ JS源码压缩的一个方法：通过parser将所有变量名替换成短串，根据出现频率来分配串长度，最高频的名字被替换成单字母a,b,c,d等...
+ 用eval可以parse JSON，更严格的应该用JSON.parse
    + 可以用toJSON定义序列化到JSON的方法
