## 1. Effective Modern C++

### Deduce Types
+ Item 1: Understand template type deduction
    + 形参声明的推导结果:
        + T -> 形参是值。可以绑定到任何实参，实参的引用、const/volatile都丢弃，发生拷贝或移动。
        + T& -> 形参是cv/non-cv左引用。不能绑定到右值(修改但不move右值是没有意义的)，绑定到cv左值时，cv会推导在T中。
        + T const& -> 形参是const左引用。可以绑定到任何值。
        + T&& (universal reference) -> 形参是左值/右值引用，左值引用是T中有&。
    + 数组和函数
        + 形参为传值时，实参的数组和函数自动退化(decay)成元素指针和函数指针。
        + 形参为引用时，实参的数组和函数以引用方式传递。数组引用包括每个纬度的size
    + 结论
        + 就结果来说，实参的reference-ness会被忽略
+ Item 2: Understand auto type deduction
    + auto 用于类型推导时，相当于template type deduction中的T，因此auto/auto&/auto const&/auto&&分别被推导为值/可变左引用/不可变左引用/任何引用。
        + auto独有的规则，`{}`(braced initializer)作为初始化表达式时，auto被推导为initializer_list。(作为对比, `int a = {1}` 和 `auto a = {1}` 完全不同，前者定义了个int，后者定义了个`initializer_list<int>`)
    + auto 用作返回值和lambda中的时候，完全相当于T。(auto私有的规则无效，具体来说，{} 作为返回值和lambda形参的初始化表达式是error)
+ Item 3:  Understand decltype
    + decltype 以变量名为参数的时候，得到的就是变量的声明类型
    + decltype 以左值表达式为参数的时候，推导结果一定有左引用。(比如，`int x; decltype(x) y; decltype((x)) z` ，y是int，z是int&)
    + decltype(auto) 使得auto应用decltype的推导规则。(作为对比：auto -> 值；auto &->  可变左引用; auto const & -> 不可变左引用; auto && -> 任意左/右引用; decltype(auto) -> 值或任意左/右引用)
+ Item 4: Know how to view deduced type
    + 可以在edit time, compile time, runtime 来inspect一个变量/表达式的类型
        + edit time: 通过ide。不一定准确，看ide中编译器前端实现是否标准。
        + compile time: 通过编译错误。不一定准确，看编译器是否标准。
            + `template <typename T> class D;  D<decltype(x)>();` 编译错误中看到x的类型
        + runtime: 通过`boost::typeindex::type_id_with_cv<T>().pretty_name()` 来看
            + `typeid(T).name()` 是不行的：
                1. `name()`不保证可读，不同编译器下的实现不同。clang/gcc可读性较差，msvc的可读性较好。
                2. 标准规定，typeid的形参声明相当于T，所以不能反映实参的类型。

### Auto
+ Item 5: Prefer auto to explicit type declartions
    + auto 的优点：
        + 对重构友好
        + 必须初始化
        + 简化声明，比如迭代器。
        + 能够声明只有编译器知道的类型，比如lambda表达式
            + 使用auto来声明lambda表达式相比用`function<xxx>` 的优点：
                +  避免了`function<xxx>` 的多态开销，比如内部的堆分配
                + 每个lambda可以有独立的类型，传值给模板函数时，可以实例化出专有的函数实现，从而允许内联
                + 可以声明泛型lambda
        + 能够声明准确的类型，避免常见的类型陷阱
            + `unsigned size = vec.size()`，不可移植，64bit下溢出
            + `for (const pair<string, int> &p : map)`，其实发生了隐式类型转换`pair<string const, int> -> pair<string, int>`，因此p其实引用的是一个右值
    + 关于auto影响可读性的讨论
        + auto不是强制的，你可以在有必要的时候显示声明
        + auto不是c++独创的，已经在静态函数式语言和动态语言中广泛的使用
        + 可以通过ide查看实际类型
    +  auto 的缺点
        + {} 被返回值/lambda以外被推导成initializer_list，这和显示声明时结果不同
        + 会将hidden proxy暴露出来，导致undefined bahvior，需要用户自己去发现hidden proxy。比如`bool x = getBoolVector()[0];` 是ok的，而`auto x = getBoolVector()[0]` 声明了一个bool的proxy，引用了一个右值的容器，非法。
+ Item 6: Use the explicitly typed initializer idiom when auto deduceds undesired types
    + 使用static_cast将hidden proxy实例转化成被代理的类型实例
        + `auto x = static_cast<bool>(getBoolVector()[0])` 强调了这个转换的必要；而如果继续使用`bool x = getBoolVector()[0]`的话，一旦未来被人不小心refactor到auto，就break掉了，坑。

### Moving to Modern C++
+ Item 7: Distinguish between () and {} when creating objects
    + 四种初始化方法：`int x(0)`, `int x = 0`, `int x{0}`, `int x = {0}`
        + 对基本类型来说，以上四种声明等价。对用户自定义类型来说，可能是构造、拷贝构造、拷贝赋值等。
    + {}使用场合很广：
        + 初始化没有构造函数的结构体。圆括号不行。
        + 初始化容器。圆括号不行。
        + 类成员的默认值。例如，`privat: int x{0};`。赋值不行。
        + 初始化non-copyable对象。如`atomic<int> x{0}`。赋值不行。
    + {}的特有优点
        + 不允许implicit narrowing conversion。例如 `int x = 3.0`是合法的，`int x = {3.0}`是不合法的。显然隐式窄转换是不合理的，但是为兼容c又不能去掉，{} 初始化自身fix了这个问题。
        + 避免了the most vexing parse，即把一个变量的定义，parse成函数声明
            + `Widget w2()` 是函数声明，`Wdiget w2{}`是变量定义。
    + {}的缺点
        + 一旦有`initializer_list`的重载，即使有类型更匹配的其他重载，也选择`initializer_list`。例如 `Widget(int, double)` 和`Wdiget(initializer_list<int>)`，对于`Wdiget w{2, 3.0}`，选择后者。如果有`operator float() const`的话，`Wdiget w2(w)`也选择后者，而不是拷贝构造。
            + 这个问题经常遇到，因为`vector<int> v{10, 0}` 的结果是2元素容器而不是10元素容器
            + `initilaizer_list`隐藏其他重载的情况只发生在构造函数，因为，普通函数的调用语法是不同的：`a.call(1, 2)` vs `a.call({1, 2})`，不构成重载         
        + 虽说，有`initlaizer_list`的重载的时候，{}总是选它；但也有例外，`Widget w{}`选择默认构造而不是`initializer_list`构造。
    + 当为一个类添加`initialier_list`构造函数重载的时候，小心break掉客户代码。
    + () 和 {} 的选择 (个人)
        + 非模板，一律用()，只在需要初始化容器和结构的时候用{}
            + 优点是不会误调用`initializer_list`的重载
        + 模板，一律用{}。(或者交由用户选择)
            + 优点是可以初始化POD和容器、避免隐式窄转换、the most vexing parse
            + `make_shared/make_unique`内部用的是圆括号。试想：
                + 用圆括号：`make_shard<vector<int>>(10, 0)` 会构造10元素容器；`make_shared<vector<int>>({10, 0})`会构造2元素容器
                + 用花括号: `make_shared<vector<int>>(10, 0)` 会构造2元素容器；`make_shared<vector<int>>({10, 0})` 会构造2元素容器
+ Item 8: Prefer nullptr to 0 and NULL
+ Item 9: Prefer alias declarations to typedefs
+ Item 10: Prefer scoped enums to unscoped enums
+ Item 11: Prefer deleted functions to private undefined ones
+ Item 12: Declare overriding functions override
+ Item 13: Prefer const_iterators to iterators
+ Item 14: Declare functions noexcept if they won't emit exceptions
+ Item 15: Use constexpr whenever possible
+ Item 16: Make const member functions thread safe
+ Item 17: Understand special member function generation

### Smart Pointers
