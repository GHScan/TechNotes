#### 2. Engineering a compiler. 第3章，语法分析器
+ 简介
    + 语法分析的主要目的，是判断输入的单词流(每个单词都被标注成某个语法范畴(syntactic category))，是否是一个语法上有效的语句(sentence)。为了回答这个成员判定问题，我们首先需要一种形式化的方法描述语言。通过将语言限制到上下文无关语言这个集合，我们能够保证高效的回答这个判定问题。
    + 语法分析：对于形式文法(formal grammar)G，以及单词流s，词法分析要做的就是找到G生成语句s的一个推导
        + 推导应该无歧义。推导过程的graph描述，就是语法树(concrete syntax tree, parse tree)
        + 语法分析的输入是单词流，输出是推导(或者失败时的诊断信息)。如果不需要完整的推导信息(parse tree)，可以只输出抽象语法树(AST)，或者采用其他语义动作(semantic action)，直接进行解释
    + 总结：
        + 对于输入的单词流/字符流(如果没有经过Scanner的话)，语法分析尝试判定它是否是特定语言L(G)的成员。L(G)本身是无限集合，成员判定方法不明，通过将G限制为CFG，得到另一种高效的成员判断方法，即，在CFG中，能否找到唯一的一个推导，生成输入的句子。通过自底向上/自顶向下的parse，语法分析器输出错误，或者输出一个推导作为结果。推导的等价表示是具体语法树，一般不需要这样多的信息，而是输出AST，或者通过语义动作，输出其他属性值，比如表达式parse中，可以直接解释结果并返回。
+ 语法的表示
    + RE无法描述程序语言，因为它无法计数，只包含有限的状态
        + RE只是CFG的一个子集，对应产生式：A->a, A->a B
    + 我们需要比RE更强大的语言，同时具备高性能的特点。CFL正是传统的解决方案，尤其是的它的子集LR(1)、LL(1)，都能生成高效的识别器。
    + 术语(Glossary)
        + Context free grammar(上下文无关文法): 对于语言L，CFG定义了表示L中有效Sentence的集合
            + CFG的定义包括4个元素：T，NT，P，S，分别是终结符、非终结符、产生式、开始符号
        + Sentence(语句): 可以从grammar rules推导出的符号串(string of symbol)
        + Production(产生式): CFG中的每个规则(grammar rule)都称为一个产生式
        + Nonterminal symbol(非终结符): 是语法变量(syntactic variable)，用来进行抽象(abstraction)和表达结构(structure)
            + 正是因为NT的存在，CFG支持递归，进而比RE更强大
        + Terminal symbol(终结符): L(G)中单词的集合，对应Scanner输出的语法范畴(syntactic category)
        + Goal symbol/Start symbol(开始符号): 
        + Derivation(推导): 对开始符号，应用一系列重写(rewrite，选择产生式来替换非终结符)，得到语句的过程。
        + Sentential form(句型): 有效推导过程中出现的符号串(string of symbol)
            + 句型对应推导过程中部分完成的Parse tree的下边缘
        + Parse tree/Syntax tree(语法分析树/语法树)：A graph that represents a derivation
        + Leftmost derivation、Rightmost derivation(最左/最右推导): 一种推导，每次都重写最左/右的非终结符
        + Ambiguity(二义性): 如果L(G)中的某个句子有多个最左/最右推导，则说文法G具有二义性
    + CFG的层次结构，由大到小
        + 任意CFG：Earley算法可以在O(n^3)的时间内解析
        + LR(1): 从左到右扫描，右推导，允许lookahead一个单词
        + LL(1):
        + RG: 正则文法，和RE等价
+ 自顶向下语法分析(Top-down parsing)
    + 使用Topdown-parsing的时候，CFG的很大一个子集可以无需回溯的高效Parse——即Backtrack-free grammar(Predicate grammar)
    + Top-down parser需要消除左递归，否则将是死循环
        + 直接左递归(direct left recursion): 
            + 通过EBNF的star手法来消除
            + BNF中，实际上是：A->A b | c，改写为A -> c A2; A2->e | b A2
        + 间接左递归(indirect left recursion):
            + 使用消除循环引用的方法，即forward subsituation
            + 图算法：已知二维的有向图，先将每个节点编码成数字，于是，有向边分别指向左和右。我们通过消除指向左边的边，来使得引用总是从i指向i+1或更大，从而避免循环引用。
                1. 当i==0时，消除指向自身的引用，从而有向边总是指向0以上
                2. 对i>1，先从j=0，到j=i-1，替换每个i->j的边，每次都将得到j+1以上的边；因此，当j==i-1的时候，i将只有i以上的边；此时再消除i->i的引用，将只剩下指向右边的边
            + 在左递归文法这里，所谓i->j的边，其实是Ni -> Nj xxx，即，产生式右边的第1个位置的非终结符号，构成一条边。我们要做的就是，反复展开右边的Nj，使得右边的序号增大，直到右边只剩下i以上的非终结符好，最后再利用消除直接左递归的手法，消除i->i的引用。over
                + 这里消除直接左递归引入的新符号，不会形成左递归
    + 提取左因子(left factoring)
        + 提取左因子，使得基于预测的高效Parser成为可能
        + 形如，A-> L R1| L R2| C1 | C2，改写成 A-> L N | C1 |C2，N->R1 | R2
    + 为了减少回溯，甚至不回溯，给出Backtrack-free grammar(Predicate grammar)的定义(对应的Parser，叫Predicative Parser)
        + 首先是FirstSet: 给定终结符/非终结符，返回它的第1个终结符集合
            + 终结符(包括EOF和Empty)，其FirsetSet是自身
            + 非终结符的FirstSet，通过不动点算法来求
                + 当任意非终结符的FirstSet仍然在变化的时候，继续迭代
                + 非终结符N的FirstSet是其各个产生式右边符号序列的FirstSet的并，即FirstSet(N) = FirstSet(p1.body) | FirstSet(p2.body) | ...
                + 符号序列seq的FirstSet定义为，(FS(s1) - Empty) | (FS(s2) - Empty) | ... FS(sn)，这里，s1 s2 .. sn是seq的一个前缀，sn是第1个FirstSet不包含Empty的符号
        + 然后是FollowSet: 给定非终结符，返回它之后可能出现的终结符
            + 仍然是不同点算法
                + 对产生式p，它的定义是N -> A1 A2 ... An。初始化 tail=FollowSet(N)，从右到左迭代；如果Ai是终结符，则tail=FirstSet(Ai)；如果Ai是非终结符，先FollowSet(Ai) |= tail，然后，如果FirstSet(Ai)包括Empty，则tail |= FirstSet(Ai)，否则tail = FirstSet(Ai)
        + 最后是First+Set: 给定产生式，返回它可能的第1个终结符
            + 如果FirstSet(p.body)包含Empty，则First+Set是FirstSet(p.body) | FollowSet(p.nonTerm)，否则First+Set等于FirstSet(p.body)
        + 所谓Backtrack-free grammar，是指，文法中，对任意非终结符N，它的任意两个产生式，其First+Set不相交
            + 因此，当开始Parse非终结符N时，给定输入终结符T，总是能唯一的确定产生式，从而避免回溯
            + 即使文法不是LL1的，Predicate信息仍然能用来优化Top-down parser的性能；当然，由于需要有回溯逻辑，会比LL1 Parser慢
            + ANTLR实现了LL(k)算法
    + 没有算法能保证将任意CFG改写成LL1，但是，一般通过左递归消除、提取左因子，我们能得到LL1，或者接近LL1；前者能得到高效的无回溯Parser，后者的Predicate信息可用于提高回溯Parser的性能
    + 常见的Topdown-parsing方案包括
        + 回溯Parser
            + 注意要确保成功，应该支持非确定性Parse，这意味着，parse函数的返回应该是序列
            + Parser combinator
                + 性能取决于library的2次处理
                + 左递归
                    + 手工改写直接左递归为EBNF的rep
                    + 小心避免间接左递归
                + 回溯
                    + 手工提取左因子
                    + 尽量写成LL1的，否则开销是指数的
                + 错误处理
                    + 当不是LL1的时候，失败回溯可能不容易做(当需要到兄弟节点的子孙去回溯的时候)
            + Top-down parser: 
                + 可以递归或通过状态栈来迭代
                + 写成非确定性递归，比如，parse的返回值是Stream[Result]
                + 很容易通过First/Follow算法整合向前看信息，即使文法不是LL1的，也可以减少回溯的分支数，从而提高性能
            + 手工递归下降(hand-code recursive descent parsing)
                + 优点是是可以实施各种优化手段，比如不同的非终结符采用不同的LL(k)向前看
                + 缺点是要为每个编译器编写递归主体
        + LL1 Parser
            + 手工递归下降
                + 先处理文法(或者找源语言已有的LL1文法)：G -> 消除直接、间接左递归 -> 提取左公因子 -> 计算First+Set，最后提供每个产生式的预测符号给编码者
                + 每个非终结符内部都可以进行细节调优
            + Table driven LL1 Parser
                + G -> remove left recursion -> left factoring -> Map[NonTerm, Map[Term, Production]]，最后编写Parser主体(递归/迭代)，根据Predicate table来选择产生式
            + Direct code LL1 Parser
                + 根据Predicate table生成一组递归调用的函数
        + LL(k) Parser
            + ANTLR
+ 自底向上语法分析(Bottom-up parsing)
    + 推导，是从开始符号，经历一系列句型，最终得到语句的过程。推导的过程是Top-down的，因此，Bottom-up，就是推导的逆过程，即，从语句开始，经历一系列句型得到开始符号。Top-down过程，每次选择最左的产生式进行rewrite，因此是Leftmost derivation；而Bottom-up过程，由于输入单词流，是从左到右的，每次需要归约当前符号串，所以，相当于reversed rightmost derivation。
    + Top-down parser，是从开始符号往下完成Parse tree，任何时候，栈上保存的是部分完成的Parse tree的下边缘；Bottom-up parser，是从单词流往上完成Parse tree，任何时候，栈中保存的是部分完成的Parse tree的上边缘。
    + LR(0)乃至LR(k)，识别的上下文无关语言是一样大的，只是接受的文法不同，k越大，接受的文法越多，而k越小，则要求文法编写者以更复杂的方式提供文法。
    + 判断一个文法是否是LR的，最简单的办法是构建LR Parser，看是否产生Shift-reduce或者Reduce-reduce冲突。
    + 术语
        + Handle(句柄): 由产生式p和位置k一起构成了一个句柄。(A->B, k)，意思是，在LR语法分析器的累积状态k处，进行一次A->B的归约，得到的新的句型(由累积状态作为前缀，还未接受的单词流作为后缀)是有效推导的句型序列的一部分
        + Shift(移入): 把输入单词流中的下一个单词放入累积符号栈中，并更新DFA状态
        + Reduce(归约): 将当前累积符号栈的栈顶符号序列，重写为一个非终结符，并更新DFA状态
        + Reduce-reduce conflict: 下一个单词，导致的归约有多个，不确定应该执行哪个操作。Ambiguity grammar
        + Shift-reduce conflict: 下一个单词，既可以移入，也可以归约。Ambiguity grammar
        + LR0 item(LR0 项): 由产生式，及当前位置构成。当前位置的取值是0~p.body.length
            + 根据位置的情况，项可能分三种：
                1. Possibility: 可能的，pos == 0
                2. Complete: 完成的。可归约，pos == p.body.length
                3. Partially complete: 部分完成的。pos > 0 && pos < p.body.length
        + LR1 item(LR1 项): LR0 item的基础上，加上一个Lookahead符号(终结符)
        + Core LR1 item: 开始符号的所有项，或者非开始符号的位置>0的项
            + 所有非核心项，都可以从核心项closure出来。所谓closure操作，即，如果位置pos后紧接一个非终极符，那么，将它的所有Possibility项加入集合，递归该过程直到不动点
        + set of LR1 items: LR1 item的集合。因为LR parser的状态机，本质上是支持递归的DFA，所以如果把LR1 item看做NFA状态，那么，set of LR1 items就是LR1 item的配置，对应DFA状态
        + Canonical collection of sets of LR1 items: LR1项集的规范簇。看做整个DFA
    + LR语法分析器算法
        1. 准备Action表
            + Action表是2维表，第1维输入是状态号，第2维输入是终结符
            + 查表结果有三种
                1. Reduce p: 表示归约产生式p
                2. Shift j: 移入当前符号，并转移到状态j。DFA查询
                3. Accept: 当前输入合法。输入流应该只剩下List(Eof)
        2. 准备Goto表
            + Goto表是2维表，第1维输入是状态号，第2维是非终结符
            + 查表结果是另一个状态号，表示归约的结果。这里也是DFA查询
        3. 算法
            1. 准备状态栈和符号栈，状态栈用于支持递归的DFA句柄查找，符号栈用于根据语义动作(Semantic action)聚合结果，输出CST、AST等
            2. 将初始状态入栈
            3. 查询Action表，Action(stateStack.top, scanner.top)，差别结果：
                + Shift j: 将输入token压入符号栈，将DFA转移的目标状态j压入状态栈，递归
                + Reduce p: 从符号栈弹出p.body个符号并执行语义动作然后压栈；从状态栈弹出p.body个状态，然后查Goto(stateStack.top, p.nonTerm)并压入状态栈，递归
                + Accept: 如果输入只剩下List(Eof)，则语言识别成功，将此时符号栈上的结果输出
        + 本质上，LR算法其实是通过DFA来查找句柄，只不过通过栈引入了递归逻辑；每次归约的时候，从栈上弹出产生式的body，恢复DFA的上一个状态，然后根据归约的NonTerm继续进行DFA查找
            + 之所以可以通过DFA查找句柄，是因为，由句柄的集合构成的语言，是有限的，而有限的语言，总是可以通过DFA描述
    + Action、Goto表的构建算法
        + 公共步骤，构建DFA：从开始符号的0位置项集出发，closure过后，遍历所有终结符/非终结符，move(set, symbol)得到各个衍生核心项集。这里的每个核心项集，是一个DFA状态。
        + LR(0): 没有向前看符号。先构建DFA后，可以开始构建Action、Goto表。每个DFA状态之间的NonTerm迁移，添到Goto表中作为一项。Term迁移，作为Action表中的Shift动作。如果一个项集，有Term迁移，同时也有归约项，则构成Shift-reduce conflict，如果有多个归约项，则构成Reduce-reduce conflict。一般处理成，Term边构成Shift，非Term边一律Reduce
            + DFA状态少，容易conflict
            + 每个DFA状态，一旦有多个Reduce项、或者同时有Reduce项和Term边，都conflict。因此接受的文法少
        + SLR: 在LR0的基础上，对于有Reduce项的项集，只以其产生式左边的NonTerm的FollowSet作为向前看符号，因此，允许单一DFA状态有多个Reduce项或同时有Term项，只要FollowSet不想交，都不构成conflict
            + DFA状态少。和LR(0)状态数一样
            + Reduce的FollowSet相交(或者与Term边相交)才构成conflict。因此接收的文法比LR(0)大
        + LALR: 先构建DFA。对于每个项集(DFA状态)中的项(表示为项集号+项)，计算它的自生成向前看符号，以及它和其他项的传播关系，然后用不动点的方式，传播向前看符号。最终DFA中的每个状态的项，都带有一个向前看符号集合，这个集合是FollowSet的子集，因此允许的文法比SLR大
            + 自生成向前看符号和传播关系
                + 对于核心项(p, pos)，以SPECIAL_TERM为向前看符号计算closure并move，如果一个target项，以SPECIAL_TERM为向前看符号，则原始项和target项构成传播关系；否则，产生的lookAhead作为target项的自生成符号，用于将来的传播
            + DFA状态少。和LR(0)状态数一样
            + 通过生成、传播的方式构造每个项的向前看符号集，因为它总是FollowSet的子集，所以conflict更少，接收的文法范围更大(注意LR parse接收的语言都一样)
        + LR(1): 以带Lookahead的开始项，构建DFA。最后Reduce的时候，以自带的Lookahead作为向前看符号
            + DFA状态多，因为Lookahead将区别不同的核心项集。状态多，因此更少的conflict，接收更大的文法；但同时空间开销大，C语言的Parser对应的LALR只需要数百状态，LR1需要数千状态
            + 每个Reduce的Lookahead集合更精确，是LALR传播生成的Term集合子集，所以更少冲突
                + 构造LALR的另外一种方法，是先构造LR(1)，然后合并所有LR0部分相同的LR1项集，向前看符号取并集。这里的合并，不会产生Shift-reduce conflict，但是会产生Reduce-reduce conflict，这也说明LALR接收的文法比LR1小
    + Bottom-up parser类型
        + Table driven LR parser: LR Parser的标准算法
        + Direct code LR parser: 根据Action、Goto表生成代码。以代码的方式模拟带递归的DFA
+ 实践中的问题(Practical issues)
    + Error recovery
        + 由于ide等工具的需要，编译器应该能一次parse反馈尽量多的错误
        + 一种做法是，通过synchronizing word来同步parser状态
            + LL1 parser：发现错误后(调用中抛出的异常)，忽略一系列输入，直到发现对应当前NonTerm帧的同步单词，然后从当前NonTerm帧返回代表错误的语法树
            + LR1 parser: 发现错误后，忽略输入直到找到同步单词，然后连续弹出状态栈，直到发现某个状态存在Goto[s, NonTerm]，于是压栈Goto项，当做Parse成功(得到是错误语法树)
            + 常用的同步单词是“;”、“}”等
    + Unary operator
        + 添加一元运算符要谨慎
    + Handing context-sensitive ambiguity
        + 比如，在C语言中，如果不通过[]和()区分数组访问和函数调用的话，那么，由于无法区分Factor中的`array-ident ( opt-exp-list )`与`function-ident ( opt-exp-list )`，必然导致歧义
            + 可以在CFG中合并两个产生式，然后在语义分析中通过类型来区分
            + 也可以将类型信息通过符号表反馈给Scanner，然后Scanner对不同类型的ident分别输出array-ident、function-ident等
    + Left recursion versus Right recursion
        + Top-down parser只能右递归，没得选(需要的话，必须将直接/间接左递归转换成右递归)
        + 对于Bottom-up的LR parser来说，左递归、右递归都是允许的
            + 左递归的状态栈深度固定，边移入边归约；而右递归对栈的需求是线性的，只有移入所有子节点后，才进行连续的归约
            + 无论左递归还是右递归，显然语义不能破坏，比如结合性
+ 高级主题
    + 优化文法(Optimizing a grammar)
        + 如果能改写文法，使得推导的语法树高度减小，那么，对于LL parser来说，意味着更少的递归调用；对LR来说，意味着更少的Reduce(显然Shift次数不会变，恒等于输入流长度)，那么，性能会有所提高
        + 减少语法树层次的一种方法是，将useless production(即其右边只有一个符号的产生式)代入到每个引用中，这将减小最终语法树的层次。但由于产生式代换有可能导致产生式总数目增加，对LR parser来说，意味着更多的状态，所以反而有可能降低性能(对dcache不友好)；而如果是LL parser，可以通过人工调整代码，稍微弥补产生式数量增加带来的开销
    + 压缩LR1表
        + 分别压缩Action表和Goto表，使得相同的行/列被合并，在每次查表之前，经过一个`状态->行号`、`符号->列号`的映射
        + 在文法上面，合并引用相同的终结符号
        + 将Table driven parser改为Direct code parser，后者将不再处理空的单元格。同时由于避免了循环(label+goto)，通过适当调整代码排布，有可能得到更好的icache亲和性
        + 如果语言足够简单，不容易conflict的话，考虑SLR、LALR，他们的状态数和LR0一样
#### 8. Design Patterns: Elements of Reusable Object-Oriented Software
+ Creational Patterns(创建型模式)
    + Abstract factory(抽象工厂)
        + Intent(意图)：提供一个创建一系列相关或相互依赖的对象的接口，而无需指定它们具体的类
        + Motivation(动机): 考虑LookAndFeel，为保证客户代码可以无缝切换不同的LAF，客户不应该直接使用具体LAF下的窗口组件，而应该通过LAF工厂来创建窗口组件的接口，然后在组件接口集上进行操作
        + Applicability(适用性)
            + 系统要独立于产品的创建、组合和表示时
            + 系统想要在多个产品系列之一做配置时
        + Participants(参与者)
            + AbstractFactory => WidgetFactory
            + ConcreteFactory => WindowsWidgetFactory, MacWidgetFactory
            + AbstractProduct => Button, ScrollBar
            + ConcreteProduct => WindowsButton, WindowsScrollBar
        + Consequences(效果)
            + 分离具体的类：客户只依赖于抽象工厂接口，而不依赖于具体工厂和具体产品
            + 易于切换产品系列。只需传入不同的具体工厂
            + 利于产品的一致。即，任意时刻，只能访问同一个具体工厂创建的产品，不可能出现WindowsDialog+MacButton的组合
            + 难以添加新产品，因为那样需要修改抽象工厂和所有具体工厂
        + Known uses(已知应用)
            + LookAndFeel
            + WindowSystem
            + RDBMS API
                + 比如Python的PEP249规定的DB-API 2.0，符合这组API的模块，如sqlite、mysql等，可以无缝切换，客户代码完全不用修改(唯一的变换是import和connection创建)
                + 微软的OLE DB也是例子
        + Related Patterns(相关模式)
            + Abstract factory通常被实现为工厂方法(Factory method)的集合，但是也可以通过Prototype实现
            + 具体工厂一般是Singleton
    + Builder(构建者)
        + Intent: 将一个复杂的创建过程，与创建的结果分离，使得基于同样的创建过程，可以创建不同类型的对象
        + Motivation: 考虑将RTF(Rich text format)转换成其他格式。因为RTF的parse过程很复杂，为每种格式编写转换过程，将非常困难。通过抽象出Builder接口，然后在Parse过程中将相应的事件转发给Builder的方法，从而允许传入代表不同目标格式的具体Builder，复用同一套Parse+Build代码
        + Applicability
            + 创建对象的复杂算法，应该独立于对象的组成、装配方式时
            + 构造过程允许创建不同的表示(具体产品)时
        + Participants
            + Builder => RTFConverter
            + ConcreteBuilder => ASCIIConverter, TeXConverter, TextWidgetConverter
            + Director => RTFParser (或者RTFReader)
            + Product => ASCIIText, TeXText, TextWidget
        + Consequences
            + 允许改变产品
            + 将构造代码和表示代码分离
            + 可以对构造过程进行精细控制(相比构造函数的一步到位，Builder pattern可以一步步来做)
        + Known uses
            + RTFConverter
            + Parser作为Director，ProgramBuilder作为Builder，ASTBuilder、Evaluator作为ConcreteBuilder
            + ClassBuilder: 客户代码去一步步创建类的字段、方法
            + ByteCodeStream: 客户代码去逐步添加指令(操作码+操作数)
        + Related patterns
            + Builder与Abstract factory相比，前者强调的是，一步步去创建一个复杂对象，而后者是强调创建一组关联对象(通常单个创建是一步到位的)
    + Factory method(工厂方法)
        + Intent: 定义创建对象的接口，然后由具体实现去决定实例化哪个产品
        + Motivation: 比如，在框架中创建产品，而具体产品可配置(通过配置不同的工厂方法)，客户代码仅依赖于产品接口和工厂方法接口
        + Applicability
            + 不想依赖具体的产品类型时
            + 希望延迟产品的创建到子类时
            + 将产品的创建委托给帮助类，从而将产品类型的选择，局部化到帮助类中(抽象工厂模式是一个例子，其中某个具体工厂就是一个局部化了类型选择的帮助类)
        + Participants
            + Product
            + ConcreteProduct
            + Creator
            + ConcreteCreator
        + Consequences
            + 将具体产品的创建延迟到子类，相当于向子类开放了一个Hook
        + Known uses
            + MVC
        + Related patterns
            + 常被用于Abstract factory、Template methods
    + Prototype(原型)
        + Intent: 用原型实例指定创建对象的类型及数据，通过拷贝原型创建新对象
        + Motivation: 常见文档编辑工具提供的模板文档功能，比如Unity中的Prefab
        + Applicability
            + 当类的实例状态只有有限的组合、或常见初始状态只有有限组合时，可以枚举这些组合存储为原型，然后在需要的时候拷贝
        + Participants
            + Prototype
            + ConcretePrototype
                + 事实上，不要求类型不同，只要实例状态不同、代表常见案例即可
            + Client
        + Consequences
            + 具有Abstract factory、Builder模式的优点，客户不依赖于具体原型的类型
            + 允许运行时修改原型列表
            + 允许改变属性值来添加新的原型
                + 相比之下，其他Creational pattern是用于抽象创建的类型，而Prototype是抽象创建的实例的(当然也能抽象创建的类型)，比前者更动态
            + 增加原型数量并不需要增加新的类型
        + Known uses
            + 文档编辑器允许定义文档模板
            + 窗口编辑器允许自定义控件模板
            + 常见的游戏引擎都支持定义游戏对象模板
        + Related pattern
            + Abstract factory、Composite、Decorator都可以从Prototype中受益
    + Singleton(单例)
        + Intent: 保证一个对象只有一个实例，并提供全局访问点
        + Motivation: 相比全局变量，Singleton追加了唯一实例的保证
        + Applicability
            + 要求唯一实例
            + 要求唯一实例，且实例的具体类型能够被延迟到子类中决定
        + Participants
            + Singleton
        + Consequences
            + 对唯一实例的受控访问
            + 允许对表示精细化：具体实例可以由子类决定
            + 可以以类似方式，将实例个数控制到K个
        + Known uses
        + Related patterns
            + ConcreteFactory、ConreteBuilder都可以被实现为Singleton
+ Structural Patterns(结构型模式)
    + Adapter(适配器)
        + Intent: 将一个类的接口转换为客户希望的另一个接口，使得原本不兼容的代码可以一同工作
        + Also known as: Wrapper
        + Motivation: 有时，为复用被设计的类不能被复用，仅仅是接口不兼容，所以可以加一层适配器
        + Applicability
            + 相比适配一个具体类，如果改为适配一个接口的话，相当于为目标接口实现了一组具体类
        + Participants
            + Target
            + Client
            + Adaptee: 被适配的接口
            + Adapter: 实现Target接口的Adaptee的Wrapper
        + Consequences
        + Known uses
        + Related patterns
            + Adapter对比Decorator，虽然同为Wrapper，但前者源/目的类型不同，而后者相同，结果是后者可递归组合
            + 对比Proxy，和Decorator类似，Proxy的源/目的类型也相同
    + Bridge(桥接)
        + Intent: 将抽象和实现分离，使得它们都可以独立变化(接口变化，和类层次变化都可)
        + Motivation: 抽象和实现通过继承来关联，在某些时候可能太强了，因为，这意味着，抽象和实现接口应该相同，类层次应该相同；但实际上，很有可能抽象中的大部分代码，都是与实现无关的，因此，可以通过增加一个额外层次，通过组合而非继承来关联抽象和实现，于是双方都可以独立变化，抽象中与实现无关的代码，可以放在抽象的接口中，从而复用。简单来说，就是将一个抽象层拆分成两个抽象层
        + Applicability
            + 你需要抽象和实现动态绑定，即允许运行时切换实现部分
            + 需要允许分别扩充抽象和实现的类层次
        + Participants
            + Abstraction: 持有Implementor实例
            + RefinedAbstraction: Abstraction的子类
            + Implementor
            + ConcreteImplementor: Implementor的子类
        + Consequences
        + Known uses
            + WindowSystem: Window(Abstraction), ResizableWindow(RefinedAbstraction), WindowImpl(Implementor), WindowsWindowImpl(ConcreteImplementor), MacWindowImpl(ConcreteImplementor)
            + STL的Stack/Queue接收一个序列类型作为参数，这里的Stack/Queue即是Abstraction，序列类型是Implementor，Vector/List可以作为ConcreteImplementor参数
        + Related patterns
            + Abstract factory可以用来配置一个Bridge
    + Composite(组合)
        + Intent: 将对象组合成树形结构，并且单个对象和对象的组合，对用户提供一致的抽象，用户可以不加区分的使用(即Combinator)
        + Motivation: Line、Rectangle、Picture等Graphic对象的组合，仍然是Graphic对象
        + Applicability 
            + 想向用户提供组合的能力，并且允许用户统一的使用组合结果
        + Participants
            + Component => Graphic
            + Leaf => Line、Rect、Text
            + Composite => Picture，即包含子Component的Component
            + Client
        + Consequences
            + 组合可以递归，任何用到基本对象的地方都可以使用组合对象，客户代码避免了选择等分支，新增加基本对象也可以无缝接入
        + Known uses
            + GUI
            + AST中的Expr
        + Related patterns
            + Decorator可能被用在Composite中
            + Iterator可以遍历Composite
            + Visitor将分布在Composite的各个子类中的操作局部化(对操作开放，对类型封闭)
    + Decorator(装饰)
        + Intent: 动态的给对象添加功能，比派生子类更灵活
        + Also known as: Wrapper
        + Motivation: 动态的给对象添加功能；相比通过派生子类的方式来静态的添加功能，Decorator可以控制类型、顺序
        + Applicability 
            + 不影响其他对象的情况下，动态、透明的方式添加职责
            + 某些正交的职责，如果通过子类的方式来组合，将导致组合爆炸
        + Participants
            + Component
            + ConcreteComponent
            + Decorator: 实现Component接口，并持有另一个Component指针
            + ConcreteDecorator: 添加各种职责
        + Consequences
            + 比继承更灵活，甚至可以重复添加同一个特性
        + Known uses
            + Logger(扩展得更厉害一点就成了Combinator了(即Composite))
            + Stream
        + Related patterns
            + vs Adapter: Decorator改变职责但不改变接口；Adapter改变接口但不改变职责
            + vs Composite: Decorator可以看做蜕化的Composite。而且Decorator本身也完全没有对象聚合的意思
            + vs Strategy: Decorator增加职责，但接口不变，提供一致的语义；而Strategy虽然接口不变，但语义变化
    + Facade(外观)
        + Indent: 为子系统中的一组接口提供一个高层接口，这个接口更容易使用
        + Motivation: 一个常见的使子系统间通信和依赖最小化的办法，即使用一个外观对象
        + Applicability 
            + 各种模式的使用，使得产生各种更小的类，从而更可定制，但对于不需要定制的上层用户，需要一个简单的接口
            + 引入Facade类使得子系统对客户不可见，从而可升级和移植
            + 在层次系统中，为每个层次提供Facade类，简化子系统的依赖关系
        + Participants
            + Facade => Compiler
            + Subsystem classes => Scanner、Parser、AST
        + Consequences
            + 对客户屏蔽了子系统组件类，使得客户依赖的类数量减少，同时接口也更简化
            + 客户也可以绕过Facade类直接访问子系统类，从而得到定制能力
        + Known uses
            + Compiler
            + Webkit
        + Related patterns
            + vs Mediator: 外观类用于沟通客户代码和子系统，子系统并不知道外观类的存在，子系统间的通信不经过外观类；中介者存在于子系统类之间，子系统类可能并不知道另一个类，而是只知道中介者
    + Flyweight(享元)
        + Intent: 运用共享技术有效的支持大量细粒度对象
        + Motivation: 有些技术受益于对象化的抽象，但是这种简化实现代价很大，比如文本编辑器中的单个字符如果都支持字体颜色不同的话。通过将状态划分为外部状态和内部状态，并共享内部状态到flyweight池中的flyweight对象中，然后在上下文相关的外部状态被引用时，访问共享的flyweight状态并传入外部状态进行操作
        + Applicability 
            + 对象数量大，内存占用多，能够区别内部/外部状态，并且将内部状态共享的话，能够显著减少内存占用，同时内部状态不应该有标识符
        + Participants
            + Flyweight
            + ConcreteFlyweight: 包含内部状态
            + FlyweightFactory: Flyweight pool的角色，让get or create的动作透明化
            + Client: 负责维护外部状态和访问Flyweight pool
        + Consequences
            + 会引入额外的时间开销，因此，仅当共享的内部状态够多时，才有价值。如果外部状态是通过内部状态计算出来的，空间效益最大化
        + Known uses
            + 文档编辑器中，将每个符号作为对象，而将Glyph等信息作为内部状态，只将位置作为外部状态
            + GUI中的Layout，首先它是Strategy的应用，其次，它可以被实现为Flyweight
            + String interning
        + Related patterns
            + 在Composite中，以Flyweight的方式实现叶节点
            + 常用Flyweight实现State、Strategy
    + Proxy(代理)
        + Intent: 为其他对象提供一种代理以控制对对象的访问
        + Motivation: LazyValue是一种Proxy的使用
        + Applicability 
            + Remote Proxy: 为对象在不同地址空间提供局部代表
            + Virtual Proxy: LazyValue的使用就是Virtual proxy，意在控制对象创建的开销，在访问的时候才执行
            + Protection Proxy: 为对象的访问权限
            + Smart reference: 为指针访问附加操作，如引用计数
        + Participants
            + Subject
            + RealSubject
            + Proxy: 实现了Subject接口
        + Consequences
            + 在引用时附加操作，比如隐藏地址空间不同的事实，按需创建对象，附加内务处理包括Copy-on-write等
        + Known uses
            + 远程代理、延迟加载
        + Related patterns
            + vs Adapter: Proxy的输入输出接口相同，或者输出是输入接口的子集(Protection proxy)；而Adapter的输入输出接口不同
            + vs Decorator: 某些种类的Proxy的确是Decorator，但一般Proxy不支持动态的添加/分离
+ Behavioral Patterns(行为模式)
    + Chain of responsibility(责任链)
+ 总结
    + Creational patterns
        + Abstract factory
            + 目的：将产品系列的创建抽象出来，提供切换整个系列而不改变客户代码的能力
            + 例子：`IQueryResult result = Modules["Sqlite"]["Connection"].New().CreateQuery("select * from db")`, `IQueryResult result = Modules["Mysql"]["Connection"].New().CreateQuery("select * from db")`
            + 场合： 框架或库
        + Builder
            + 目的：对于复杂的创建过程，抽象创建器，从而复用同一份创建代码，生成不同的产品
            + 例子：`new JsonBuilder().BeginArray().Value(1).Value(2).EndArray().Result()`、`new BisonBuilder().BeginArray().Value(1).Value(2).EndArray().Result()`
            + 场合：一个类的创建过程很复杂，如树/图的构建，或参数很多如GUI控件
        + Factory method
            + 目的：提供动态类型创建能力
            + 例子：`ISet set = Module.GetType("HashSet").New()`、`ISet set = Module.GetType("OrderedSet").New()`
        + Prototype
            + 目的：通过状态(而非代码)来区分不同的模板。如果行为的不同，必须通过代码来区别，这往往意味着不同的类型；而如果仅由不同的数据状态，就能驱动行为，那仅需要相同类型的不同实例即可；前者是First class type，后者是Prototype
            + 例子：`Human h = CharacterTemplates["Soldier"].Clone()`、`Human h = CharacterTemplates["Doctor"].Clone()`
            + 场合：First class type的动态性仍不足以满足需要时，Prototype列表可运行时修改这一特性，可能正好满足需求；游戏引擎、Word/PPT中常见
        + Singleton
            + 目的: 唯一实例
            + 例子：`Application.onExit = ()=>{println("Application exit");}`
            + 场合：逻辑上应该避免多实例的情况，比如只有一个StringPool做intern
    + Structural patterns
        + Adapter
            + 目的：适配接口(又叫Wrapper)
            + 例子：`new InputStream(libc.stdin)`
        + Bridge
            + 目的：在抽象和实现之间，引入一个新的抽象-实现层，通过将原本的实现中大量重复代码，提取成implemention-independent代码，作为抽象中的代码复用。即，原来是`A1 - I2`，现在是`A1 - I1, A2- I2`，代码提取过后，两个类层次和接口都可以分别变化，典型的例子是，层次1大而深，但接口都很简单，而层次2小，接口比较复杂。
            + 例子：`Window::DrawRect() { windowImpl->DrawLine(); ... windowImpl->DrawLine(); }`, `ResizeableWindow::Draw() { super.DrawRect(); }`, `WindowImpl::DrawLine() {}`, `MacWindowImpl::DrawLine() {}`
            + 场合：实现代码中，如果不依赖具体实现的代码很多，那么可以将它们抽象出来，使得他们只依赖实现的抽象，这样的通过组合进行的层次刨分，更大程度的复用了代码
        + Composite
            + 目的：提供可组合语义，其实就是Combinator
            + 例子：`Expr = Add(Const(1), Variable("x"))`
            + 场合：概念本身递归、可组合；做DSL
        + Decorator
            + 目的：蜕化版的Composite，透明、动态的添加职责
            + 例子：`new ZipInputStream(new FileStream("1.zip"))`
            + 场合：可能有多个正交的概念需要组合，同时组合的顺序、次数也不限，此时用继承会导致类型爆炸
        + Facade
            + 目的：打包一组类对外提供简单的接口，在子系统类和客户代码之间，起到解耦和简化API的作用
            + 例子：lua的那组c api
            + 场合：提供简化的接口，或者出于减小层次子系统间依赖的考虑
        + Flyweight
            + 目的：大量对象时共享状态从而节省空间。注意要求能区分内部/外部状态
            + 例子：String interning，树的叶节点
            + 场合：空间压力大，重复数据多
        + Proxy
            + 目的：在引用对象的时候附加额外操作
            + 例子：远程代理、延迟加载(LazyValue)
            + 场合：需要控制对象访问时
    + Behavioral Patterns
        + Chain of responsibility
