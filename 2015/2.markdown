#### 1. Engineering a compiler. 第5章，中间表示
+ 简介(Introduction)
    + 所谓IR，即Intermediate representation
    + 在编译的各个pass之间，应该传递一种能够作为整个程序权威表示的IR(definitive IR)，它包含了程序的完整语义，以及编译的过程中推断出来的中间信息；过程中可能会创建衍生IR(derivative IR)用于特定目的，如DAG(Directed acyclic graph)、CFG(Control-flow graph)、Data dependence graph、Call graph
    + IR可以从3个方面分类
        1. 结构性的组织(Structural organization)
            + Graphical IR: 如Parse tree、AST、DAG、CFG、Data dependence graph、Call graph
            + Linear IR: 如One-address code、Two-address code、Three-address code、SSA(Static single-assignment form)
            + Hybrid IR: 如用CFG来表示控制流，而CFG中单个节点所代表的Basic block用三地址码来呈现
        2. 抽象层次(Level of abstractions)
            + 不同的抽象层次因为表达粒度不同，在优化等方面各有用途，比如接近源码层次树形IR很容易发现数组引用和函数调用的实参，而底层线性IR则很难发现这些事实；另一方面，上层IR可能没有表达变量的存储方式，而底层IR则编码了这些信息，并可针对它们进行优化
            + 底层IR也可以包含类似min、max、memcpy等常见模式，通过将这些抽象暴露给底层，从而使得这些操作有机会得到特殊优化
        3. 命名机制(Naming discipline)
            + 可以考虑根据值和无副作用的基本操作的组合来命名临时变量，从而达到value numbering的效果，避免冗余计算等；因为这种类似DAG的操作，要求无副作用，因此，针对赋值、非纯函数调用等副作用，可以通过重命名变量来使得变量的值、类型都不可变，于是可以安全的缓存计算；相比随意的重命名变量，考虑到在Basic block的入口，需要汇集前驱基本块的原始变量的值，所以，重命名的时候，保留原始变量的信息更好，这就是SSA的做法
+ 图IR(Graphical IR)
    + 各种图IR在抽象层次、与底层代码的关系、结构等方面，各有不同
    + Parse tree: 一般只用于讨论语法分析和Attribute grammar中。
    + AST
        + 抽象层次接近源码，一般语法分析器可以直接创建
        + 被很多编译器和解释器使用
        + 常用于源到源的转换系统，可以轻易生成源代码
        + Lisp的S表达式本质上就是AST
    + DAG(Directed acyclic graph): 通过重写AST中重复子表达式得到，一般用作节省空间或消除冗余计算(此时只是中间过程的衍生IR)
        + 共享节点要求无赋值、无副作用
    + CFG(Control flow graph): 控制流图对基本块间的控制流动建立了模型
        + 基本块(Basic block): 无分支的最长操作序列。操作总是全部执行，除非触发异常。每个基本块可能有多个后驱(Jump对应1个后驱，CBR对应2个后驱，Jump register对应N个后驱、TBL对应K个后驱)
        + 一般为简化讨论，假设CFG只一个入口(多个入口的时候，可以通过建立N0，并连接N0到所有入口得到)，和一个出口(多个出口的时候，建立Nk，并连接所有出口到Nk)
        + 有循环的时候，CFG可能是带环图
        + 相比采用基本快作为CFG的基本单位，另一种选择是使用单语句块(Single statement block)作为基本单位，优点是创建简单，缺点是CFG节点规模太大
        + 可以轻易从线性IR创建CFG
        + 指令调度和全局寄存器分配都可能依赖CFG
    + Data-dependence graph: 模拟代码片段中值的定义和使用之间流动的图
        + 每个节点表示线性IR中的一个语句，节点间的每条有向线段，表示值的定义到值的使用，对应值必须先定义再使用的约束
        + 依赖图表示的代码片段的执行顺序，是一种partial order，比Linear IR中的implicit order更弱，这就给诸如指令调度的优化提供了重排(rearrange)的余地，使得out-of-order优化成为可能
        + 可能需要编码控制流信息
        + 难点是数组/指针的引用。粒度太大，比如考虑整个数组，则意义不大；降低粒度去分析数组/指针的槽，则需要精确的分析(编译期模拟运行时行为是不可能彻底的)
    + Call graph: 用来表示过程间调用关系的图，每个节点表示一个过程，每条边表示一个Call site
        + 为解决跨过程边界的效率低下问题，一些编译器需要过程间分析优化(Interprocedural analysis and optimization); 为表示运行时过程间控制转移，编译器使用调用图
        + 术语
            + Interprocedural: Any technique that examines interactions across multiple procedures is called interprocedural
            + Intraprocedural: Any technique that limits its attension to a single procedure is called intraprocedural
        + 一些工程因素和语言特性使得Call graph构建复杂
            + Separate compilation
                + 一些编译器为编译单元(compilation unit)中的所有过程建立部分调用图(partial call graph)，并在该集合上进行分析和优化。在这样的系统中要进行过程间分析，要一次性传递所有源码给编译器。
                + 现在的一些C/C++编译器开始在link edit time进行过程间优化；JVM等JIT编译器在loading time或execution time进行过程间分析
            + First class function: 这往往被实现为`call r`，直接的，应该建立该调用点到所有过程的边；编译器应该进行分析，以限制这里的边的集合
                + CFG中也存在类似问题，由于`jump r`的存在，该基本块的后驱应该是其他所有基本块；通过类似tbl的指令，显示的枚举目标基本块的集合，从而限制后驱数量
            + Runtime polymorphism(如Subtyping): 这里的二义性调用，需要引入更多的类型信息才有可能解决
                + 部分语言可以通过分析类层次来消除二义性(比如C++/Java的虚函数内链)，其他语言只能在运行时通过Type feedback来处理
+ 线性IR(Linear IR)
    + 使用线性IR的原因
        + 输入的源码是线性，输出的目标码也是线性
        + 早期编译器作者是汇编出身，采用汇编作为IR符合直觉
        + 相比data-dependence graph的partial order，线性IR定义了一种确定的顺序
        + 如果definitive IR使用线性，则必须编码控制流。一般通过Jump和Conditional branch来表达
            + 一般硬件ISA的CBR使用一个跳转目标，通过为IR设计两个跳转目标(Taken branch和Not-taken branch)，避免了Fall-through branch
    + 单地址码(One-address codes mode)
        + 模拟累加器(Accumulator machine)、栈机器(Stack machine)
        + 易于生成、易于优化(实际的寄存器分配策略可以后期决定)、空间占用小(所以常被叫做Bytecode，易于传输)
        + 很容易转换成三地址码等
        + 从抽象层次上来说，也允许使用max、min、mvcl等高层指令
        + Smalltalk 80和JVM、CLR
    + 两地址码(Two-address codes mode) 
        + 模拟了有破坏性操作(Destructive operation，即一个源操作数寄存器会被改变)的机器，由于内存限制越来越不重要，已经很少使用了
    + 三地址码(Three-address codes mode)
        + 类似RISC指令，即两操作数及目标，往往四字节就可以表示一个指令了
        + 易于生成、易于优化
        + 从抽象层次上来说，也允许使用max、min、mvcl等高层指令
        + SSA
    + 线性IR的表示
        + 可以使用指令的链表，由于允许高效的扩容，所以很适合被用在前端，此时的指令规模未知
        + 指令指针的数组，或者4元组(两操作数+目标+操作符)的数组。由于数组允许线性索引，所以在指令调度阶段的重排中很合适
    + 一些编译器的选择
        + IBM的Fortran H，使用三地址码(四元组)和控制流图组合
        + GCC，要求每种语言实现GIMPLE接口(树IR)，然后根据GIMPLE建立SSA，得到RTL(Register transfer language)进而优化
        + LLVM，静态类型的三地址码，支持数组、结构、向量(SIMD)，对于标量使用SSA
    + 根据线性IR建立CFG
        + 遍历IR，每发现一个Label即创建一个新的基本块；检查每个基本块的结束指令，如果是JUMP，则创建边连接到目标块；如果是CBR，建立两条边到Take branch和Not-taken branch的基本块；如果是JUMP r，则建立边连接到所有的基本块
+ 将值映射到名字(Mapping values to names)
    + Naming temporal value: 根据源操作数及运算符来为临时值命名，从而将值的信息编码到名字中，为优化提供了可能。这里类似DAG的value numbering优化，要求无副作用。
    + SSA Form: 每个定义(definition point)都有不同的名字，在控制流合并的位置插入Thi函数
        + SSA encodes both control and value flow。
        + Thi函数的行为取决于运行时的控制流，根据源基本块的不同，本基本块开头的一组Thi函数会进行并行的赋值
        + 在三地址码中表达Thi函数，操作数不止2个，因此该条指令可能较大
        + 将线性IR转换成SSA的方法：深度遍历基本块集合，对于每一次变量赋值，重命名到更大编号；在下一个基本块开头添加Thi函数并重命名。相比后文的专门的SSA构建算法，这里的简单方案得到的Thi操作较多，有待优化
    + 内存模型(Memory models)
        + Register-to-register model: 编译器激进的将所有值保存在寄存器中，只当语义需要才将值写回内存(如跨函数边界的非局部变量、传递局部变量地址给另一个函数)
            + 后续的寄存器分配算法，可能由于物理寄存器数量太少，而增加额外的store(Register spilling)、load指令，造成指令规模增大
        + Memory-to-memory model: 将所有值保存在内存中，仅当需要才将值加载到寄存器，操作过后再写回内存
            + 后续的寄存器分配算法，会优化掉多余的store、load操作，从而使得指令规模更小
        + 一般IR的选择和内存模型的选择是正交的
        + RISC更倾向于选择R2R模型，因为它更符合RSC的ISA，只需要少许调整
+ 符号表(Symbol table)
    + 为避免每次引用一个符号时，搜索IR去寻找定义，所以使用中央存储即符号表
    + hash表可以用做稀疏图(sparse graph)，缺点是无法进行遍历，比如查找某节点的所有后继节点
    + 避免hash算法退化的一种方法是，改用multiset discrimination，即，直接从词法分析器拿到所有token的集合，然后排序，并为每个不同的lexeme分配一个id作为hash值；即通过离线算法得到完美hash
    + 为将嵌套词法作用域(lexical scoping)的程序的每个变量引用映射到对应的定义，需要lexical scoped symbol table
        + 这个查找过程称为name resolution
        + 这里的scoped hash table也可以用来优化，比如被用在super local value-numbering中
        + 变量在相应存储区中的偏移量的(level, offset)对，被叫做静态坐标(static coordinate)
    + 符号表还会被用作Structure table，即用来管理自定义类型的名空间。符号表在这里有几种用法：
        + Separate table: 即每个结构一个表。优点是允许枚举单个结构的名空间，并允许和scoped hash table类似的处理流程
        + Selector table: 用限定的前缀以及字段名(field-selector)组成的table，在公共的表中索引
        + Unified table: 在全局符号表中索引
    + OO语言如Java的嵌套作用域更复杂，包括函数本身的作用域、外层词法作用域、类的名空间、父类的名空间、当前包的名空间(涉及跨文件符号)、import包的名空间
    + hash表还可以用作pure function的memoizing等

#### 3. Engineering a compiler. 第6章，过程抽象(The procedure abstraction)
+ 简介(Introduction)
    + 术语
        + Caller: in a procedure call, we refer to the calling procedure as the caller
        + Callee: in a procedure call, we refer to the procedure that is invoked as the callee
        + Function: the callee may return a value to its caller, in which case the procedure is termed a function
        + Linkage convention: an agreement between the compiler and operation system that defines the actions taken to call a procedure or function
            + 也叫做calling convention?
        + Actual parameter: a value or variable passed as a parameter at a call site is an actual parameter of the call
        + Formal parameter: a name declared as a parameter of some procedure p is a formal parameter of p
    + 过程提供了三个关键抽象，使得我们能构建重要程序
        + Procedure call abstraction: 使得程序员可以调用其他人的代码或库/系统服务
        + Name space: 过程有一个新的、受保护的命名空间，使得过程在不同的上下文中调用的时候，都可以正确一致的运行
        + External interface: 定义了大型软件系统各个部分之间的接口，程序员和编译器不用关注callee的细节
+ 过程调用(Procedure calls)
    + 术语
        + ALL: Algol-like language
        + Activation: a call to a procedure activates it, thus, we call an instance of its execution an activation
        + Closure: a procedure and the runtime context that defines its free variables
        + Execution history:
        + Call graph:
    + 分析caller-callee关系的一个关键数据结构是call graph，它表示了过程之间发生的各个调用(call site)；虽然call graph捕获了源码定义中的静态关系，但它未能捕获动态关系如调用次数
+ 命名空间(Name spaces)
    + 术语
        + Scope: in a algol-like language, scope refers to a name space, the terms is ofen used in discussion of the visibility of names
        + Lexical scope: scopes that nest in the order that they are encountered in the program are often called lexical scopes; in lexical scoping, a name refers to the definition that is lexically closest to its use, that is , the definition in the closest surrounding scope
        + Dynamic scoping: a free variable is bound to the variable by that name that was most recently created at runtime
        + Static coordinate: for a name x declared in scope S, its static coordinate is a pair (l,o), where l is the lexical nesting level of S and o is the offset where x is stored in the scope's data area
        + Activation record: A region of storage set aside to hold control information and data storage associated with a single instance of a single procedure
        + Activation record pointer: To locate the current AR the compiler arranges to keep a pointer to the AR, the activation record pointer is a desgined register
        + Leaf procedure: a procedure that contains no calls
        + Just-in-time compiler: Schemes that perform some of the tasks of a traditional compiler at runtime are often called just-in-time compilers or JITs. in a JIT, compile time becomes part of runtime, so JITs place an emphasis on compile-time efficency
        + Direct superclass: 
        + Closed class structure: If the class structure of an application is fixed at compile time, the OOL has a closed hierarchy
            + 于是，依靠类层次结构信息，方法内部的name resolution可以在编译期进行
            + C++ has a closed class structure, any functions, other than virtual functions, can be resolved at compile time, virtual functions require runtime resolution
        + Open class structure: If an application can change its class structure at runtime, it has an open hierarchy
            + 比如，Java支持运行时import类(loading time?)，Smalltalk允许运行时修改类
        + Name resolution:
        + Dispatch: The process of calling a method is often called dispatch, a term derived from the message-passing model of OOLs such as Smalltalk
        + Method caches:
        + Inline method cache:
        + Fully qualifed name:
    + 词法作用域(lexical scoping)背后的一般原理很简单：在一个给定的作用域中，每个名字引用在词法位置上与之最接近的声明
        + 词法作用域中，编译器可以为每个名字分配静态坐标，进而在最终的代码生成中给出地址
        + 与词法作用域相对的是动态作用域(dynamic scoping)，在早期的解释器中它很容易实现，但在编译器中高效实现比较困难。动态作用于仍然存在于一些语言如Common lisp中
    + ALL语言的运行时支持
        + 为实现过程调用和作用域化的命名空间这两个孪生抽象，编译器用到一个同时涉及控制和命名两方面的关键数据结构，活动记录(Activation record)。原则上，每次过程调用都会产生一个新的AR
        + 常见的AR包括:
            + 参数区(Parameters)
            + 返回地址(Return address): ret过后caller代码段的地址
            + 返回值(Return value): 指向caller接收返回值的地址
            + 寄存器保存区(Register-save area)
            + 调用者的ARP(Caller's ARP)
            + 局部数据区(Local-data area)
                + 一般寻址变量的时候，使用`Rarp + immediate`，如果遇到可变大小的变量(如C99的变长数组)，可能需要增加额外的间接寻址
                + 静态变量存储在静态数据段，由loader来初始化；自动变量存储在AR中，由专门的代码初始化
            + 可寻址性(Adressability): 用来寻址free-varaible的指针，根据实现不同，可能是access link(static link，指向上一层ARP)，也可能是GD(global display)上一level的指针
        + AR中的字段，一般区分静态长度部分，和可变长度部分(参数区和局部变量区)，通过将可变部分布局在两端，从而允许函数无关的遍历AR
        + 分配AR
            + 栈分配: 如果语言不支持first class function，不允许closure作为返回值，那么，AR的生命期满足LIFO，因此AR的分配可以直接用native stack
                + 对free-variable的寻址可以使用GD，即静态坐标(l,o)中的l，可以直接取GD数组l位置处的最近AR，然后寻址o对应的局部变量。bound variable的寻址总是一次`load a, imm`，而free-variable的寻址也是O(1)的，只是多一次间接寻址
            + 堆分配: 如果语言允许closure作为返回值，那么，callee的AR可能被引用住(在callee内部创建closure)，生命期超过caller的AR，从而不满足LIFO，只能使用AR链，形成树
                + 对free-variable的寻址可以使用access link(static link)，即沿AR链上溯(lm-ln)次(这里的(lm-ln,o)是静态距离坐标，static distance coordinate)，然后寻址o；bound varaible寻址是O(1)的，free varaible寻址是O(k)的
            + 静态分配：compile time binding的leaf procedure作为callee的时候，caller知道callee不会再调用，所以可以直接将callee的AR分配在静态区(应该是线程安全的，比如TLS)
            + 合并分配：如果a->b->c总是无条件调用，那么，可以考虑调用a的时候一次性分配a+b+c的AR
    + OO语言的命名空间
        + 传统的先收集程序所有的信息再处理的策略，对某些OO语言不可行，它们的一些特性导致直到运行时才能推断命名空间，这依赖解释器或JIT
        + OO术语: Class, Object, Inheritance, Receiver(方法调用总是相对某个对象的(runtime dispatch)，即this/self)
    + OO语言的运行时支持
        + 由于对象的生命期和过程调用无关，因此需要专门的OR(Object record)来保存状态
        + 一个典型的OO语言OR组织:
            + 对象OR：类指针 + 方法表指针 + 成员字段集合
                + 对于Closed class hierarchy，方法表中包含了继承得的所有方法；而对于可能频繁变化的Open class hierarchy，方法表可能只包含类自身的方法，父类的方法需要沿链表上溯
            + 类OR：类指针(指向根class) + 方法表指针(基本为空) + 方法集合，其中类指针和方法表指针，所有class OR都相同
        + 方法调用: 总是相对对象的runtime dispatch，因此一般是从OR上取得方法表指针，再取得方法，最后调用；如果是开放类结构，可能需要沿继承链搜索方法(可以用method cache优化)
        + OR布局
            + 对于单根继承，可以总是在superclass的字段后追加本类的字段，这样的OR在传给superclass的方法时，仍然是兼容的，这种做法叫prefixing
                + 对于多重继承，subclass可能需要将没有override的非prefix的superclass方法，用thunk(或者说trampoline)来wrap一下，使得this指针在进入方法前增加一个偏移、退出方法后减小一个偏移
            + 如果class structure很少改变，可以由解释器/JIT在每次改变后调整OR布局和方法表，这样总的开销仍然可控
            + 如果class structure频繁改变，使用OR链、方法链，性能可能更高
        + 分派
            + Closed class hierarchy中，像C++这样的静态语言，可以将除虚方法之外的其他方法做static dispatch；如果C++编译器能够证明某个虚方法调用的receiver不会变，也可以直接生成调用，进行静态分派
            + Open class hierarchy
                + 结构很少改变：每次改变后重建OR和方法向量
                + 结构频繁改变：使用OR链和方法链，只记录当前类数据，在进行runtime name resolution的时候沿链搜索
                    + 为降低搜索开销，可以引入method cache，即用一个hash表来缓存查找结果(可以采用least recently used策略)
                    + 更进一步的，根据type locality，同一个call site的receiver类型很少变化，即方法调用往往是单态的，所以可以进行inline method cache
                + 可以通过运行时分析，证明某个调用的接收器总是同一个类型，从而进行静态分派
        + 多继承
            + 对于多继承中的非prefix superclass，子类应该将没有override的方法给wrap一下，在thunk中调整self指针
+ 过程之间的值传递(Communication values between procedures)
    + 术语
        + Call by value: a convention where the caller evaluates the actual parameters and passes thire values to the callee, any modification of a value parmeter in the callee is not visible in the caller
        + Call by reference: a convention where the compiler passes an address for the formal parameter to the callee, if the actual parameter is a variable(rather than an expression), then changing the formal's value also changes the actual's value
        + Call by name: a reference to a formal parameter behaves exactly as if the actual parameter had been textually substituted in its place, with appropriate renaming
        + Call by need: the implemention creates and passes thunks that are invoked the first time that the parameter value is actually referenced, the thunk, or promise, stores its result for subsequent references
        + Alias: when two names can refer to the same location, they are said to be aliases
        + Data area: The region in memory that holds the data for specific scope is called its data area
            + Base address: The address of the start of a data area is often called a base address
        + Name mangling: The process of constructing a unique string from a source-langauge name is called name mangling
    + 参数
        + 标量直接存储在寄存器中，或者直接存储在callee的AR参数区中；大型值，可能需要程序员主动指定传引用
    + 返回值
        + 如果返回值较小，那么可能直接通过寄存器返回，或者将值放在callee的AR的返回值slot中，由caller读取；否则由caller在AR中准备返回值空间，然后将返回值地址传给callee
    + 可寻址性(Adressability)
        + 静态基地址的变量: 全局和静态变量，可以通过数据区基址的标号(relocable)，加上立即数寻址
        + 动态基地址的变量
            + bound variable: `Rarp + immediate`
            + free variable: 根据实现是GD或者access link，分别寻址
                + GD对display的维护，access link对prev ARP指针的维护，在leaf procedure(compile time binding的)中是不必的
+ 标准化链接(Standardized linkages)
    + 术语
        + Precall sequence:
        + Postreturn sequence:
        + Prologue sequence:
        + Epilogue sequence:
        + Caller-save registers: The registers designed for the caller to save are caller-save registers
        + Callee-save registers:
    + 过程linkage是编译器、OS、目标机在命名、资源分配、寻址、保护这些任务上，清晰划分指责的结果
        + The procedure linkage is a contract between the compiler, the operation system, and the target machine that clearly divides responsibility for naming, allocation of resources, addressability, and protection
    + 过程linkage允许用户代码、系统库、其他程序库、以及其他语言过程之间的互操作性
        + The procedure linkage ensures interoperability of procedures between the user's code, as translated by the compiler, and code from other sources, including system libraries, application libraries, and code written in other programming language
    + 一般来说，在目标机+OS的某个组合上，所有的编译器都使用相同的linkage
        + Typically, all of the compilers for a given combination of target machine and operating system use the same linkage, to the extent possible
        + 这个约定一般是编译器开发者和OS开发者在系统开发早期商定的
    + linkage将过程调用从它的每个调用环境中隔离了出来
        + The linkage convention isolates each procedure form the different enveironments found at call sites that invoke it
    + Save registers
        + 将更多的代码移到prologue/epilogue  sequence中，而不是precall/postreturn sequence中，可以使目标码更小；因此后者在每个call site上都要重复
        + 对于常驻寄存器的值(比如this)，我们倾向于callee-save，因为callee知道它是否会用、是否有必要save，而caller却没有这些信息；对于非常驻数据，我们倾向于caller-save，因为这些数据只在caller上下文中有意义，caller自己来保存
    + 管理display和access link
        + 一般在prologue sequence或者precall sequence中开始维护
+ 高级主题(Advanced topics)
    + 术语
        + Precise collector: 依靠类型信息进行精确标记、回收
        + Conservative collector: 扫描内存，尝试识别指针。可能把普通数据识别为指针，导致垃圾不能及时释放。一般用于C语言这种缺乏运行时类型信息的系统
    + 堆的显示管理(Explicit heap management)
        + Multipool allocator: 一个freelist数组，分别负责不同尺寸的内存块儿的管理。关键是在free的时候根据指针计算块儿size:
            + 方案1: 利用指针的位模式计算page number，然后在页的第1个字里面存放size
            + 方案2: 利用指针的位模式计算page number，然后根据page number查找多级页表，从entry当中取出信息如该页的块size
            + 方案3: 带类型的NEW和DELETE，传递size、alignemnt给底层分配器，从而避免分配器保存size的任务
        + Arena-based allocation: 就是栈分配器，分配的时候指针加法，没有单独的free，使用完毕过后一次全部释放
        + Debuging Help
            + 利用boundary tag，进行越界检查
            + 额外的一个字，链接所有allocated块，提供dump整个已分配堆的能力
            + 额外的一个字，指向分配点的文件、行号字符串，用于跟踪泄露
            + 存储分配的timestamp，帮助调试
    + 隐式释放(Implicit deallocation)
        + Reference counting: 缺点：
            1. 释放一棵树的根的时候，会导致当场释放整颗树，耗时很长导致卡顿。对策是提供一个free链表，逐渐释放
            2. 环。对策是reachability analysis
            3. 由于每次赋值都更新计数，而赋值的次数远远多于分配次数，导致实际的摊还开销很大
        + Garbage collection: the implicit deallocation of objects that reside on the runtime heap
            + 标记阶段的任务是将所有的变量、临时值、寄存器，都识别为可达对象
            + Mark-Sweep是O(N)的，而Copy GC是O(k)的
            + Mark-Sweep也可以进行compaction
            + Copy GC不需要专门的标记阶段
            + Incremental collector也被叫做Realtime collector

#### 6. Engineering a compiler. 第7章，代码形式(Code shape)
+ 简介(Introduction)
    + Keywords: Code generation, control structure, expression evaluation
    + The concept "code shape" encapsulates all of the decisions, larget and small, that the compiler writer makes about how to represent the computation in both IR and assembly code
        + Careful attension to code shape can both simplify the task of analyzing and improving the code, and improve the quality of the final code that the compiler produces
    + 编译器在给定处理器上实现大多数源语言结构时，都可以有多种方法，不同的方法使用不同的操作和途径；其中一些更快，一些内存更少，一些寄存器更少，一些能耗更低。我们将这些差别归因于代码形式
    + 代码形式会强烈的影响到编译后代码的行为，以及优化器和后端改进代码的能力。比如:
        + switch可以编译成线性的if-then-else、jump table、hash表、二分查找，每种方案有其适应场合，性能各不相同
        + 加法由于Commutativity和Associativity的性质，连续加法的AST可以有多种组织形式，不同的顺序，在constant folding、value numbering面前优化的机会各不相同
+ 分配存储位置(Assigning storage locations)
    + Glossary
        + Physical register: a named register in the target ISA
        + Virtual register: a symbolic name used in the IR in place of a physical register name
        + Page: the unit of allocation in a virtual address space. The operating system maps virtual pages into physical page frames
        + Spill: when the register allocator cannot assign some virtual register to a physical register, it spills the value by storing it to RAM after each definition and loading it into a temporary register before each use
        + Unambiguous value: a value that can be accessed with just one name is unambiguous
        + Ambiguous value: any value that can be accessd by multiple name is ambiguous
    + 编译器必须为代码的各个值分别分配一个存储位置，为此，编译器必须理解值的类型、长度、可见性和生命周期；编译器必须考虑内存的运行时布局、源语言对数据区和数据结构布局的约束，目标处理器对数据位置或使用的约束
        + 命名值的生命周期由源语言规则和代码中的实际用法确定。比如静态变量必须跨调用保持
            + The lifetime of a named value is defined by source-language rules and actual use in the code
        + 编译器在处理未命名值时有更大的自由度，放置在何处、保持多长时间，编译器的余地很大
            + The compiler has more freedom in how it treats unnamed value
        + 编译器还必须为每个值作出决定，是保存在寄存器中还是内存中，一般来说，编译器会采用一个内存模型。两种常见的策略是内存到内存模型和寄存器到寄存器模型
            + Memory to memory model: 所有值都在内存中，计算时加载到寄存器，求值后写回内存(简单JIT可以用这个方案...)
                + 在该方案下，后续的物理寄存器分配器环节，只是优化，而非必须
            + Register to regsiter model: 假设有足够寄存器用于计算，只在语义需要的时候写回内存：
                + 以引用作为参数或返回值
                + 用户指定volatile关键字
                + 指针或数组造成ambiguous value
                + 后期register allocator分配物理寄存器溢出时
                + 在该方案下，后续的物理寄存器分配器环节，是必须的，不可省略
        + 编译器会将值集中到各个数据区，每个数据区中的值都有相同的存储类别
            + the compiler will group together values into data areas in which each value has the same storage class
    + 编译器、OS、CPU协作，以确保多个程序能够以时间片为单位安全执行。有关程序地址空间布局、操控和管理的许多决策超出了编译器编写者的职责范围
        + 就地址空间而言，编译器的视角(View)是单个进程的虚拟地址空间，上面分布着代码段、数据段、栈、堆等数据区；OS的视角是，多个进程运行在各自的虚拟地址空间中，最后由OS+MMU将它们映射到物理地址空间中；CPU的视角是物理地址空间
    + Cache相关概念: tag, line, direct-mapped cache, set-associative cache, fully associatve cache, associative search(以tag在set中搜索line，常见替换方案有random replacement, least-recently used), hit ratio=cache hit/cache miss
        + 某些ISA向应用程序开放高速缓存提示指令，以指示prefetched、flushed
    + Assigning Offset: 某些ISA限制了数据项在内存中的放置，比如32位整数必须按32位字边界对齐、64位整数必须从64位双字对齐，这叫做alignment rule
        + 为了遵循alignment rule, 编译器可能会插入padding
        + 一些语言对layout有限制，比如C的struct，要求必须按声明顺序排列，可能要求pack; 而java的class和Algol-like language的局部变量区，编译器可以自由安排顺序
        + 当允许编译器安排顺序时，为了遵循alignment rule，编译器可以按alignment从大到小依次安排(如果不考虑性能相关的cache line、page因素的话)(甚至JVM允许将子类的字段插入到基类的padding之中)
        + 某些ISA在jump之外还提供了call指令，它可能对AR的格式和AR的起始地址有对齐要求(如MacOSX要求AR必须16字节对齐)
    + Relative offsets and cache performance:
        + 可能编译器希望将两个关联值一起加载到cache中，这就需要让两个值的相对偏移尽量控制在cache line大小以内。如果只考虑两个值的相对偏移，是可以处理的，但如果考虑到各组变量的交互，那么是NP-complete的。
        + 如果两个值的距离超过了page size(比如，其中一个值是很大的数组)，由于经过MMU的物理地址偏移是runtime binding的，编译器无法控制，其性能也就无法估量，因此编译器倾向于让频繁操作的值被放置在同一page、甚至是同一cache line中
    + Keeping values in registers: 在寄存器到寄存器模型中，编译器倾向于将值尽量保存在寄存器中；后续的寄存器分配阶段，可能会由于物理寄存器不足某些值被spill到内存
        + 除非：
            + 静态分配的变量第一次使用时需要加载
            + 传引用的参数和返回值需要加载或写回
            + 用于通过volatile等feature显示指定
        + 编译器可以保存在寄存器中的值称为unambiguous value
        + 有多个名字的值称为ambiguous value，成因包括指针/引用，数组元素；对于歧义值，除非编译器能证明两个名字的值集不想交，否则每次赋值后，都必须重新加载值
            + 为了优化指针/引用造成的pointer aliasing，编译器可能需要进行interprocedural data-flow analysis
            + 为了优化数组元素的访问，编译器需要进行data-dependency analysis
            + 语言特性可能帮助改善问题，如C的restrict和volatile(被用于硬件设备中断、interrupt service routine修改的变量，多线程修改的变量)
    +  本书的简单三地址码生成规则有几个优点(每次引用值的时候都分配一个虚拟寄存器):
        + 简化代码生成器
        + 方便后续阶段改进分析和优化结果
        + 避免将machine-dependent的约束写进IR中，比如字长/立即数长、寻址方式等，从而增强了编译器的可移植性
+ 算数运算符(Arithmetic operators)
    + Glossary
        + Rvalue: an expression evaluated to a value is an rvalue
        + Lvalue: an expression evaluated to a location is an lvalue
    + 现代处理器为表达式求值提供了全面支持，典型的RISC机器具有完全的三地址操作
    + 三地址形式使得编译器能够命名任何操作的结果，避免了二地址形式的主要复杂性--destructive operation
    + 简单的表达式代码生成可以通过后序遍历，为了减少寄存器需求，可能需要先对每颗子树计算寄存器个数，然后求值时，按寄存器数从多到少依次进行
        + 这里编译器安排求值顺序的自由性，这么像C/C++那样，除了sequence point外不限制求值顺序(哪怕是副作用操作)；对于Java/C#这种有严格求值顺序(从左到右)的语言，只能对无副作用操作(可能需要进行过程间分析以证明某些表达式无副作用)进行乱序
    + 本书中生成的简单三地址码，没有使用基址、偏移寻址方式，这既避免了在IR中引入机器依赖行为，也为后面的窥孔优化等提供了机会
    + 由于精度限制，计算机的浮点数只是实数的一个子集(在数轴上非均匀)，因而没有结核性和交换性，所以编译器不能重排表达式，除非语言/编译选项允许这么做
        + Due to limitations in precision, floating-point numbers on a computer represent only a subset of the real numbers, one that does not preserve associativity
    + 由于函数可能具有副作用，所以编译器不能跨函数调用进行乱序求值，除非像C/C++那样不规定顺序，或者能通过过程间分析(比如通过call graph)证明无副作用
    + 通过将类型转换操作视作一个IR指令，后续的优化步骤能将之视为整体进行消除、移动
        + 基本类型的转换操作，要么由目标ISA提供专门指令；要么被编译器实现为机器相关的一组操作
        + 对于用户自定义的类型转换，用户会提供转换过程
    + 虽然赋值一般是右结合的，但它的求值顺序也可能是从左到右(比如Java)，其中，赋值号左边是lvalue，求值结果是地址，右边是rvalue，求值得到一个值
    + 一些优化如充分利用处理器寻址模式、调度指令充分利用issue rate、寄存器分配，都无法很好的和树遍历框架(treewalk framework)集成，因此，生成最简单的IR更好
+ 布尔运算符和关系运算符(Boolean and relational operators) 
    + Glossary
        + Short-circuit evaluation: This approach to expression evaluation, in which the code evaluates the minimal amount of the expression needed to determine its final value, is called short-circuit evaluation
        + Predicated execution: an architectural feature in which some operations take a boolean-valued operand that determines whether or not the operation take effect
+ 数组的存储和访问(Storing and accessing arrays)
    + Glossary
        + False zero: the false zero of a vector V is the address where V[0] would be, in multiple dimensions, it is the location of a zero in each dimension
        + Dope vector: a descriptor for an actual parameter array, dope vector may also be used for arrays whose bounds are determined at runtime
+ 字符串(Characters strings)
+ 结构引用(Structure references)
+ 控制流结构(Control-flow constructs)
    + Glossary
        + Tail call: a procedure call that occurs as the last action in some procedure is termed a tail call. A self-recursive tail call is termed a tail recursion 
        + Jump table: a vector of lables used to transfer control based on a computed index into the table
+ 过程调用(Procedure calls)
